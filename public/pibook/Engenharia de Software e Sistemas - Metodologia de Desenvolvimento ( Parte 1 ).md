Capítulo. Engenharia de Software e Sistemas - Metodologia de Desenvolvimento ( Parte 1 ).


Índice

1) Apresentação do Prof. Diego Carvalho - Informática

2) Noções Iniciais sobre Metodologias de Desenvolvimento - Parte 1

3) Metodologias de Desenvolvimento - Parte 1 - Processos de Desenvolvimento

4) Resumo - Metodologias de Desenvolvimento - Parte 1

5) Questões Comentadas - Metodologias de Desenvolvimento - Parte 1- CESPE ..

6) Questões Comentadas - Metodologias de Desenvolvimento - Parte 1- FCC

7) Questões Comentadas - Metodologias de Desenvolvimento - Parte 1- FGV

8) Questões Comentadas - Metodologias de Desenvolvimento - Parte 1-
Diversos

9) Lista de Questões - Metodologias de Desenvolvimento - Parte 1 -CESPE

10) Lista de Questões - Metodologias de Desenvolvimento - Parte 1 - FCC

11) Lista de Questões - Metodologias de Desenvolvimento - Parte 1 - FGV

12) Lista de Questões - Metodologias de Desenvolvimento - Parte 1 -
Diversas


APRESENTAçÃo

FORMADO EM CIÊNCIA DA COMPUTAÇÃO PELA
UNIVERSIDADE DE BRASÍLIA (UNB), PÓS-GRADUADO EM
GESTÃO DE TECNOLOGIA DA INFORMAÇÃO NA
ADMINISTRAÇÃO PÚBLICA E, ATUALMENTE, AUDITOR
FEDERAL DE FINANÇAS E CONTROLE DA SECRETARIA DO
TESOURO NACIONAL.

®) PROFESSOR DIEGO CARVALHO - WWW.INSTAGRAM.COM/PROFESSOROIEGOCARVALHO

Sobre o curso: galera, todos os tópicos da aula possuem Faixas
de Incidência, que indicam se o assunto cai muito ou pouco em
prova. Diego, se cai pouco para que colocar em aula? Cair pouco
não significa que não cairá justamente na sua prova! A ideia aqui
é: se você está com pouco tempo e precisa ver somente aquilo
que cai mais, você pode filtrar pelas incidências média, alta e
altíssima; se você tem tempo sobrando e quer ver tudo, vejam
também as incidências baixas e baixíssimas. Fechado?

INCIDÊNCIA EM PROVA: BAIXÍSSIMA
INCIDÊNCIA EM PROVA: BAIXA

^NcÍDENcíflEMPRÕmoÃ
INCIDÊNCIA EM PROVA: ALTA
INCIDÊNCIA EM PROVA: ALTÍSSIMA

Além disso, essas faixas não são por banca - é baseado tanto na
quantidade de vezes que caiu em prova independentemente da
banca quando das minhas avaliações sobre cada assunto...


#ATENÇÃO

Avisos
Importantes

O curso abrange todos os níveis de conhecimento...

Esse curso foi desenvolvido para ser acessível a alunos com diversos níveis de
conhecimento diferentes. Temos alunos mais avançados que têm
conhecimento prévio ou têm facilidade com o assunto. Por outro lado, temos
alunos iniciantes, que nunca tiveram contato com a matéria ou até mesmo que
têm trauma dessa disciplina. A ideia aqui é tentar atingir ambos os públicos -

iniciantes e avançados - da melhor maneira possível..

Por que estou enfatizando isso?

O material completo é composto de muitas histórias, exemplos, metáforas, piadas, memes, questões,
desafios, esquemas, diagramas, imagens, entre outros. Já o material simplificado possui exatamente o
mesmo núcleo do material completo, mas ele é menor e bem mais objetivo. Professor, eu devo estudar
por
qual material? Se você quiser se aprofundar nos assuntos ou tem dificuldade com a matéria,
necessitando
de um material mais passo-a-passo, utilize o material completo. Se você não quer se aprofundar nos
assuntos ou tem facilidade com a matéria, necessitando de um material mais direto ao ponto, utilize
o
material simplificado.

questões possuem um comentário mais simplificado porque têm o único
objetivo de apresentar ao aluno como bancas de concurso cobram o
assunto previamente administrado. A imensa maioria das questões para
que o aluno avalie seus conhecimentos sobre a matéria estão dispostas ao
final da aula na lista de exercícios e possuem comentários bem mais
completos, abrangentes e direcionados.


Conceitos Básicos

ENGENHARIA DE SoFTwARE

INCIDÊNCIA EM PROVA: BAIXA

Vamos começar falando um pouquinho sobre Engenharia de Software! Em primeiro lugar, o
que é
um software? Bem, em uma visão restritiva, muitas pessoas costumam associar o termo
software
aos programas de computador. No entanto, software não é apenas o programa, mas também
todos os dados de documentação e configuração associados, necessários para que o programa
opere corretamente.

E a Engenharia de Software? A IEEE define engenharia de software como a aplicação de
uma
abordagem sistemática, disciplinada e quantificável de desenvolvimento,
operação e
manutenção de software. Já Friedrich Bauer conceitua como a criação e a utilização de
sólidos
princípios de engenharia a fim de obter software de maneira econômica, que seja
confiável e que
trabalhe em máquinas reais.

Em suma, trata-se de uma disciplina de engenharia que se ocupa de todos os aspectos
da produção
de software, desde os estágios iniciais de especificação do sistema até a
manutenção desse
sistema, após sua entrada em produção A meta principal da Engenharia de
Software é
desenvolver sistemas de software com boa relação custo-benefício. Conceito bem
simples,
vamos prosseguir...

De acordo com Roger Pressman: "A Engenharia de Software ocorre como consequência de um
processo chamado Engenharia de Sistemas. Em vez de se concentrar somente no
software, a
engenharia de sistemas focaliza diversos elementos, analisando, projetando, e os
organizando em um
sistema que pode ser um produto, um serviço ou uma tecnologia para transformação da informação ou
controle".

Além disso, nosso renomadíssimo autor afirma que a engenharia de sistemas está
preocupada com
todos os aspectos do desenvolvimento de sistemas computacionais, incluindo
engenharia de
hardware, engenharia de software e engenharia de processos. Percebam, então,
que a
Engenharia de Sistemas está em um contexto maior - junto com várias outras
engenharias.
Entenderam direitinho?

A Engenharia de Software tem por objetivo a aplicação de teorias, modelos, formalismos,
técnicas
e ferramentas da ciência da computação e áreas afins para um desenvolvimento
sistemático de
software. Logo, associado ao desenvolvimento, é preciso também aplicar processos,
métodos e
ferramentas, sendo que a pedra fundamental que sustenta a engenharia de software é o
foco
na qualidade conforme apresenta a imagem anterior.


Tudo isso envolve planejamento de custos e prazos, montagem da equipe e garantia de
qualidade
do produto e do processo. Finalmente, a engenharia de software visa a produção da
documentação
formal do produto, do processo, dos critérios de qualidade e dos manuais de usuários
finais. Todos
esses aspectos devem ser levados em consideração.

(TRT/io - 2013) A engenharia de software engloba processos, métodos e ferramentas.
Um de seus focos é a produção de software de alta qualidade a custos adequados.

Comentários: a engenharia de software tem por objetivos a aplicação de teoria, modelos,
formalismos, técnicas e ferramentas
da ciência da computação e áreas afins para a desenvolvimento sistemático de software.
Associado ao desenvolvimento, é
preciso também aplicar processos, métodos e ferramentas sendo que a pedra fundamental
que sustenta a engenharia de
software é a qualidade. Basta visualizar a imagem para responder à questão! Ela não
menciona foco na qualidade, mas não
restringe também somente a processos, métodos e ferramentas (Correto).

Aliás, nosso outro renomadíssimo autor - lan Sommerville - afirma em seu
livro que: "A
engenharia de software não está relacionada apenas com os processos técnicos de
desenvolvimento
de software, mas também com atividades como o gerenciamento de projeto de
software e 0
desenvolvimento de ferramentas, métodos e teorias que apoiem a produção de software".
Vamos ver
como isso cai em prova...

(MEC-2011) A engenharia de software, disciplina relacionada aos aspectos da produção
de software, abrange somente os processos técnicos do desenvolvimento de software.

Comentários: ela abrange também com atividades como o gerenciamento de projeto de
software e o desenvolvimento de
ferramentas, métodos e teorias que apoiem a produção de software (Errado).

A Engenharia de Software surgiu em meados da década de sessenta como uma tentativa de
contornar a crise do software e dar um tratamento de engenharia ao desenvolvimento de
software completo. Naquela época, o processo de desenvolvimento de
software era
completamente fora de controle, gerenciamento, monitoração e tinha grandes
dificuldades em
entregar o que era requisitado pelo cliente.

Já na década de oitenta, surgiu a Análise Estruturada e algumas Ferramentas
CASE que
permitiam automatizar algumas tarefas. Na década de noventa, surgiu a orientação a
objetos,
linguagens visuais, processo unificado, entre outros conceitos diversos. E na última década,


surgiram as metodologias ágeis e outros paradigmas de desenvolvimento muito comuns hoje
em
dia no contexto de desenvolvimento de software.

A Engenharia de Software possui alguns princípios fundamentais, tais como: Formalidade,
em que
o software deve ser desenvolvido de acordo com passos definidos com precisão e
seguidos de
maneira efetiva; Abstração, em que existe uma preocupação com a identificação
de um
determinado fenômeno da realidade, sem se preocupar com detalhes, considerando
apenas os
aspectos mais relevantes.

Há a Decomposição, em que se divide o problema em partes, de maneira que cada uma
possa ser
resolvida de uma forma mais específica; Generalização, maneira usada para resolver um
problema,
de forma genérica, com o intuito de reaproveitar essa solução em outras situações;
Flexibilização
é o processo que permite que o software possa ser alterado, sem causar problemas para
sua
execução. Professor, como a formalidade pode reduzir inconsistências?

Cenário 1: Estamos na fase de testes de software. O testador afirma que fez todos
os testes,
você - líder de projeto - acredita nele sem pestanejar, e passa o software ao
cliente homologar
se está tudo certo. O cliente tenta utilizar o software e verifica que várias partes
estão com
erros grosseiros de funcionamento. Viram como a ausência de uma formalidade pode gerar
inconsistências?

Cenário 2: Estamos na fase de testes de software. O testador afirma que fez todos
os testes e
entrega um documento de testes com tudo que foi verificado no sistema. Você - líder
de
projeto - lê o documento de testes e verifica que não foram feitos testes de carga
e testes de
segurança. Retorna para o testador e pede para ele refazer os testes. Feito isso, ele
passa o
software ao cliente, que fica feliz e satisfeito porque está tudo funcionando corretamente.

Vocês percebem que essas formalidades evitam aquele "telefone-sem-fio" que é relativamente comum?
Quanto mais eu seguir o processo, o passo-a-passo, tal qual foi devidamente definido
por
diversas pessoas ao longo do tempo a partir de suas experiências (de falhas e de sucesso) com
vários projetos, maior a minha chance de obter êxito na construção do meu software.
Bacana?
Vamos ver um resuminho...

A Engenharia de Software é uma disciplina dentro do contexto de Engenharia de Sistemas
que se
ocupa de todos os aspectos da produção de software, desde os estágios iniciais de
especificação do
sistema até a manutenção desse sistema após a sua entrada em produção (apesarde o
nome indicar
o contrário, em produção significa que o software já está disponível no ambiente real
de utilização
do cliente), passando por aspectos humanos, hardware, etc.

Além disso, ela é composta de cinco princípios fundamentais: decomposição, generalização,
flexibilização, formalidade e abstração. Por fim, é importante notar que ela se baseia
em um
conjunto de ferramentas, métodos e processos - sendo que a pedra fundamental que
sustenta a
engenharia de software é o foco na qualidade. Isso é apenas uma contextualização
inicial-esse não
é um assunto que cai com frequência em prova. Fechou? Vamos seguir então...


(Banco da Amazônia - 2010) Os princípios de engenharia de software definem a
necessidade de formalidades para reduzir inconsistências e a decomposição para lidar
com a complexidade.

Comentários: a engenharia de software possui alguns princípios, dentre os quais:
Formalidade, em que o software deve ser
desenvolvido de acordo com passos definidos com precisão e seguidos de maneira efetiva;
Decomposição, em que se divide o
problema em partes, de maneira que cada uma possa ser resolvida de uma forma mais
específica. Logo, são princípios:
Formalidade e Decomposição (Correto).

A
k

Princípios: Decomposiçdo; Generalização;
Flexibilização; Formalidade Abstração

F

F


Ferramentas


Eng. de Software <

*todos

Foco na qualidade

F


Processos de Desenvolvimento

INCIDÊNCIA EM PROVA: BAIXA

Vamos começar falando sobre ciclo de vida! Esse termo surgiu lá no contexto da
biologia. Ele trata
do ciclo de vida de um ser vivo, ou seja, trata do conjunto de transformações pelas quais passam
os indivíduos de uma espécie durante toda sua vida. Vocês se lembram lá no ensino
fundamental
quando a gente aprende que um ser vivo nasce, cresce, reproduz, envelhece e morre?
Pois é! Aqui a
metáfora ainda vale...

Vejam essa imagem: nós temos um bebê, que depois se torna uma criança,
que depois um
adolescente, que depois um jovem, que depois um adulto, que depois um velho, depois
um ancião
e depois morre! Logo, o ciclo de vida de um ser vivo trata das fases pelas quais um ser vivo passa
desde seu nascimento até a sua morte. E esse conceito pode ser aplicado a diversos
outros
contextos.

Exemplos: ciclo de vida de uma organização, ciclo de vida de sistemas, ciclo de vida
de
produtos, ciclo de vida de projetos, ciclo de vida de planetas, entre vários outros.
E como esse
conceito se dá em outros contextos? Exatamente da mesma forma! Logo, o ciclo de vida
de um
produto trata da história completa de um produto através de suas fases (Ex:
Introdução,
Crescimento, Maturidade e Declínio).

Existe também o ciclo de vida de um projeto, que trata do conjunto de fases que
compõem um
projeto (Ex: Iniciação, Planejamento, Execução, Controle e Encerramento). O que todos
esses ciclos
de vida têm em comum? Eles sempre tratam das fases pelas quais algo passa desde o seu início
até o seu fim. Então, é isso que vocês têm que decorar para qualquer contexto de
ciclo de vida:
fases pelas quais algo passa do seu início ao seu fim.


Na Engenharia de Software, esse termo é geralmente aplicado a sistemas de software com
o
significado de mudanças que acontecem na vida de um produto de software. O ciclo de
vida
trata das fases identificadas entre o nascimento e a morte de um software.
Vocês viram? É
exatamente a mesma coisa - são as fases ou atividades pelas quais passa um software
durante o
decorrer da sua vida.

Uma definição interessante de ciclo de vida de software afirma que se trata das fases
de um produto
de software que vão desde quando ele é concebido inicialmente até quando ele não está
mais
disponível para uso. Já Steve McConnell afirma que um modelo de ciclo de vida de
software é
uma representação que descreve todas as atividades que tratam da criação de um produto
de
software.

Dessa forma, nós podemos concluir que um ciclo de vida de software se refere às fases pelas
quais
um sistema de software atravessa desde sua concepção até sua retirada de produção. Bem,
entender esse conceito não é o problema, esse é um conceito muito simples. Concordam
comigo? E
qual é o problema, professor? O problema é que existem dezenas de fases diferentes
para os ciclos
de vida de acordo com cada autor.

Como assim, professor? Infelizmente, não há um consenso entre os autores. Cada um que
lança um
livro decide criar o ciclo de vida com as fases que ele acha mais corretas e isso
acaba
prejudicando nosso estudo. Na UnB, eu tive um professor de Engenharia de Software
chamado
Fernando Albuquerque que já tinha escrito vários livros sobre esse assunto e ele tinha
o seu próprio
ciclo de vida com suas respectivas fases.

Agora imaginem a quantidade de autores de livros de Engenharia de Software lançados nas
últimas três ou quatro décadas. Além disso, acontece de as vezes o próprio autor
mudar seu
entendimento sobre as fases. Se vocês olharem a quarta edição do livro do Roger
Pressman, ele
tem um conjunto de fases; se vocês olharem da sexta edição para frente, ele define
um novo
conjunto de fases. O que aconteceu? Ele mudou de ideia!

Então, eu já vi vários ciclos de vida diferentes em provas! Qual a solução para esse
problema,
professor? Galera, vocês sempre têm que pensar no custo/benefício. Vale a pena decorar
todos? Na
minha opinião, nem um pouco! Por que? Porque isso não é algo que cai
muito em prova -
principalmente nas provas recentes. Guardem o espaço que vocês têm sobrando na cabeça
para
memorizar coisas que realmente caem.

Sendo assim, percebam que há autores que descrevem as fases do ciclo de vida de
software de
maneira mais ampla e abstrata (com poucas e grandes fases) e autores que o fazem de
maneira
mais diminuta e detalhada (com muitas e pequenas fases). Vamos começar a ver alguns
ciclos de
vida que existem por aí para que vocês visualizem isso com maior clareza!


67 0'®


OPERAÇÃO

W W

CICLO DE
VIDA DE
SOFTWARE

Vamos lá! Do lado esquerdo, temos um ciclo de vida de software só com
quatro fases bem
genéricas: Definição do Software, Desenvolvimento do Software, Operação do Software e
Retirada
do Software. Eu só vi cair esse ciclo de vida uma vez, mas ele é útil para que
vocês visualizem um
ciclo de vida com poucas fases. Observem que ele trata desde o início até a
aposentadoria ou
retirada do software.

Do lado direito, eu coloquei um ciclo de vida um pouco mais detalhado. Vejam que ele
destrincha
mais as fases de desenvolvimento, separando em análise, projeto, implementação, testes,
etc. Por
que eu coloquei esse ciclo de vida? Porque alguns autores afirmam que, em tese, todo ciclo de vida
deveria contemplar todas essas atividades ou fases. Relaxa, nós vamos ver
isso com mais
detalhes depois...


T 1

II*1PLAMTAÇ0Ã

T 1

cOMUNICAÇ0Ã

k J

CICLO DE

r

PILANEJAMENU1


EVDLUÇÃ D

k J

ESENVD

VIMENTl ]

J

À VIDA (POR
PRESSNAN)


VALI-
13AÇÃE1

T 1

cONSTRUÇÃDI

k À

1MODELAGEM

k


Outros exemplos: em verde, nós temos um ciclo de vida de software de acordo com
nosso querido
autor: lan Sommerville. Ele contém quatro fases: Especificação, Desenvolvimento,
Validação e
Evolução. Sendo que, atenção aqui, o desenvolvimento pode ser dividido
em Projeto e
Implementação. Tudo certo? Esse é um ciclo de vida de software que já cai com uma
maior
frequência (nada excepcional, só cai mais que os outros).

Por fim, em laranja, nós temos um ciclo de vida de software de acordo com nosso
outro querido
autor: Roger Pressman. Ele contém cinco fases: comunicação, planejamento,
modelagem,
construção e implantação. Esse não cai tanto, mas é importante saber também. Tudo bem
até
aqui? Então vejam que não é tão complicado! Esses são os quatro ciclos de vida de
software mais
comuns em prova... e são raros!

(TCE/PR - 2016) A metodologia de processos genérica para a engenharia de software é
composta de seis etapas: comunicação, planejamento, modelagem, construção,
emprego e aceitação.

Comentários: essas etapas parecem as fases do ciclo de vida de acordo com 0 Pressman, que são:
Comunicação, Planejamento,
Modelagem, Construção e Implantação. Percebam que ele troca Implantação por Emprego e Aceitação
(Errado).

Então, vamos recapitular: inicial mente, nós vimos o conceito de um Ciclo deVida!
Depois nós vimos
o que é um Ciclo de Vida de Software. E, agora, nós vamos ver um terceiro conceito,
que é o
conceito de Modelo de Ciclo de Vida de Software. Por que, professor? Porque Ciclo de
Vida de
Software é diferente de Modelo de Ciclo de Vida de Software. E o que é um modelo
de ciclo de vida
de software?

Bem, um modelo de ciclo de vida de software é um modelo que apresenta não só as
fases do
ciclo de vida do software, mas também a forma como essas fases se relacionam. Diego,
não
entendi isso muito bem! Galera, um modelo contém as fases que nós acabamos de ver,
mas ele
também nos diz como essas fases se relacionam! Vocês querem um exemplo? Existe um
modelo de
ciclo de vida chamado Modelo em Cascata.

Esse modelo foi pioneiro - ele foi o primeiro modelo a aparecer na Engenharia de
Software e nós
vamos vê-lo em mais detalhes em outro momento. O importante sobre o Modelo em Cascata
é a
forma como as fases se relacionam. Nesse modelo, nós temos uma regra de ouro: uma
fase
somente se inicia após o término completo da fase anterior (exceto a primeira,
evidentemente) -
não é possível fazer fases paralelamente. Viram como as fases se relaciona?

Dessa forma, um Modelo de Ciclo de Vida de Software contém suas respectivas fases,
mas também
contém como essas fases se relacionam. Vejam os conceitos abaixo:


CICLO DE VIDA

- TRATA-SE DAS FASES PELAS QUAIS ALGUMA COISA PASSA DESDE O SEU INÍCIO ATÉ O SEU FIM -

CICLO DE VIDA DE SOFTWARE

- TRATA-SE DAS FASES PELAS QUAIS UM SOFTWARE PASSA DESDE O SEU INÍCIO ATÉ O SEU FIM -

MODELO DE CICLO DE VIDA DE SOFTWARE

- TRATA-SE DAS FASES PELAS QUAIS UM SOFTWARE PASSA DESDE O SEU INÍCIO ATÉ O SEU FIM E COMO ESSAS
FASES SE RELACIONAM -

E o que seria um processo de software? Então, um processo de software pode ser visto
como o
conjunto de atividades, métodos, práticas e transformações que guiam pessoas na produção
de software. Como o Modelo de Ciclo de Vida nos diz como as fases do ciclo de vida se
relacionam,
nós podemos-em termos de prova-considerar Modelo de Ciclo deVida como sinônimo de Modelo
de Processo! (Aliás, pessoal... infelizmente muitas questões ignoram isso!).

PROCESSOS DE SOFTWARE

- CONJUNTO DE ATIVIDADES, MÉTODOS, PRÁTICAS E TRANSFORMAÇÕES QUE GUIAM PESSOAS NA PRODUÇÃO DE
SOFTWARE -

MODELO DE PROCESSO DE SOFTWARE

- MESMO CONCEITO DE MODELO DE CICLO DE VIDA - É UMA REPRESENTAÇÃO ABSTRATA DE UM PROCESSO DE
SOFTWARE -

Um processo de software não pode ser definido de forma universal. Para ser eficaz e
conduzir à
construção de produtos de boa qualidade, um processo deve ser adequado às
especificidades
do projeto em questão Deste modo, processos devem ser definidos caso a caso,
considerando-se
diversos aspectos específicos do projeto em questão, tais como:

#i. Características da aplicação (domínio do problema, tamanho do software, tipo e
complexidade,
entre outros);

#2. Tecnologia a ser adotada na sua construção (paradigma de desenvolvimento,
linguagem de
programação, mecanismo de persistência, entre outros);


#2- Organização onde o produto será desenvolvido e a equipe de
desenvolvimento alocada
(recursos humanos).

(TCE/TO - 2009) A escolha do modelo do ciclo de vida não depende de características
específicas do projeto, pois o melhor modelo é sempre o mais usado pela equipe do
projeto.

Comentários: um processo de software não pode ser definido de forma universal. Eles
devem ser definidos caso a caso,
considerando-se diversos aspectos específicos do projeto em questão. Dessa forma, a
afirmação não faz 0 menor sentido! A
escolha depende das características do projeto; além disso, não existe um "melhor" modelo (Errado).

Há vários aspectos a serem considerados na definição de um processo de software. No
centro
da arquitetura de um processo de desenvolvimento estão as atividades-chave
desse processo:
análise e especificação de requisitos, projeto, implementação e testes, que são a base
sobre a qual
o processo de desenvolvimento deve ser construído. Entendido?

No entanto, a definição de um processo envolve a escolha de um modelo de ciclo de
vida (ou
modelo de processo), o detalhamento (decomposição) de suas macro-atividades, a
escolha de
métodos, técnicas e roteiros (procedimentos) para a sua realização e a definição de
recursos e
artefatos necessários e produzidos - é bastante coisa!

Podemos dizer que se trata da representação abstrata de um esqueleto de processo,
incluindo
tipicamente algumas atividades principais, a ordem de precedência entre elas e,
opcionalmente,
artefatos requeridos e produzidos. Em geral, um modelo de processo descreve uma
filosofia de
organização de atividades, estruturando-as em fases e definindo como essas
fases estão
relacionadas.

A escolha de um modelo de ciclo de vida (para concursos, sinônimo de modelo de
processo) é o
ponto de partida para a definição de um processo de desenvolvimento de software. Um
modelo de
ciclo de vida, geralmente, organiza as macro-atividades básicas do processo, estabelecendo
precedência e dependência entre as mesmas. Tudo certo?

Conforme eu disse anteriormente, alguns autores afirmam que os modelos de ciclo de
vida básicos,
de maneira geral, contemplam pelo menos as fases de: Planejamento; Análise e
Especificação de
Requisitos; Projeto; Implementação; Testes; Entrega e Implantação;
Operação; e
Manutenção. Abaixo eu trago uma descrição genérica sobre cada uma dessas fases.

DESCRIÇÃO

O objetivo do planejamento de projeto é fornecer uma estrutura que possibilite ao
gerente fazer
estimativas razoáveis de recursos, custos e prazos. Uma vez estabelecido o escopo de
software, com
um pequeno esboço dos requisitos, uma proposta de desenvolvimento deve ser elaborada,
isto é, um
plano de projeto deve ser elaborado configurando 0 processo a ser utilizado no
desenvolvimento de
software. À medida que 0 projeto progride, 0 planejamento deve ser detalhado e atualizado
regularmente. Pelo menos ao final de cada uma dasfases do desenvolvimento (análise e
especificação
de requisitos, projeto, implementação e testes), o planejamento como um todo deve ser
revisto e o
planejamento da etapa seguinte deve ser detalhado. O planejamento e o
acompanhamento do
progresso fazem parte do processo de gerência de projeto.

Nesta fase, o processo de levantamento de requisitos é intensificado. O escopo deve
ser refinado e os
requisitos mais bem definidos. Para entendera natureza do software a ser construído, o
engenheiro
de software tem de compreender o domínio do problema, as restrições, as metas, as
funcionalidades
e o comportamento esperados - ele pode o fazer por meio de diversas técnicas de
levantamento de
requisitos (Ex: entrevistas). Uma vez capturados os requisitos do sistema a ser
desenvolvido, estes
devem ser modelados, avaliados e documentados. Uma parte vital desta fase é a
construção de um
modelo descrevendo o que o software tem de fazer (e não como fazê-lo).

Esta fase é responsável por incorporar requisitos tecnológicos aos requisitos essenciais
do sistema,
modelados na fase anterior e, portanto, requer que a plataforma de implementação seja
conhecida.
Basicamente, envolve duas grandes etapas: projeto da arquitetura do sistema e projeto
detalhado. O
objetivo da primeira etapa é definir a arquitetura geral do software, tendo
por base o modelo
construído na fase de análise de requisitos. Essa arquitetura deve descrever a
estrutura de nível mais
alto da aplicação e identificar seus principais componentes. O propósito do
projeto detalhado é
detalharo projeto do software para cada componente identificado na etapa anterior. Os
componentes
de software devem ser sucessivamente refinados em níveis maiores de detalhamento
(inclusive em
relação à tecnologia adotada) até que possam ser codificados e testados.

O projeto deve ser traduzido para uma forma passível de execução pela
máquina. A fase de
implementação realiza esta tarefa, isto é, cada unidade de software do
projeto detalhado é
implementada.

Inclui diversos níveis de testes, a saber, teste de unidade, teste de integração e
teste de sistema.
Inicialmente, cada unidade de software implementada deve ser testada e
os resultados
documentados. A seguir, os diversos componentes devem ser integrados sucessivamente até
se obter
o sistema. Finalmente, o sistema como um todo deve sertestado.

Uma vez testado, o software deve ser colocado em produção. Para tal, contudo, é
necessário treinar
os usuários, configurar o ambiente de produção e, muitas vezes, converter bases de dados. O
propósito
desta fase é estabelecer que o software satisfaz os requisitos dos usuários. Isto é
feito instalando o
software e conduzindo testes de aceitação. Quando o software tiver demonstrado
prover as
capacidades requeridas, ele pode ser aceito e a operação iniciada.

Nesta fase, o software é utilizado pelos usuários no ambiente de produção, isto é, no
ambiente real de
uso do usuário.

Indubitavelmente, o software sofrerá mudanças após ter sido entregue para o usuário.
Alterações
ocorrerão porque erros foram encontrados, porque o software precisa ser adaptado para
acomodar
mudanças em seu ambiente externo, ou porque o cliente necessita de funcionalidade
adicional ou
aumento de desempenho. Muitas vezes, dependendo do tipo e porte da manutenção
necessária, essa
fase pode requerer a definição de um novo processo, onde cada uma das fases
precedentes é
reaplicada no contexto de um software existente ao invés de um novo.


Existem outras fases em outros modelos, tais como: análise, responsável por
modelar o
problema (diferente do projeto, responsável por modelar a solução do problema);
homologação,
responsável pela aceitação pela parte interessada do produto; gerência
de configuração,
responsável pela estruturação sistemática dos produtos, artefatos, documentos,
modelos, entre
outros. Bacana?

Sommerville afirma que um processo de software é um conjunto de atividades
e resultados
associados que produz um produto de software. De acordo com ele, existem
quatro atividades
fundamentais de processo, que são comuns a todos os processos de software -
são elas:
Especificação de Software; Desenvolvimento de Software (Projeto e
Implementação);
Validação de Software; e Evolução de Software.

Também de acordo nosso querido autor, um modelo de processo de software é uma
descrição
simplificada desse processo de software que apresenta uma visão dele. Os modelos de
processo
incluem as atividades, que fazem parte do processo de software, e eventualmente os
produtos de
software e os papéis das pessoas envolvidas na engenharia de software. Pois é, e
nosso autor não
para por aí...

Ele ainda afirma que a maioria dos processos de software é baseada em três modelos
gerais:
modelo em cascata; desenvolvimento iterativo e engenharia de software
baseada em
componentes. Isso entra em contradição com o que dizem outros autores, isto é, os
principais
modelos podem ser agrupados em três categorias: modelos sequenciais, modelos incrementais
e modelos evolutivo.


M0DEL05
5EQJJENCIAI5

\

PRINCIPAIS MODELOS MODELOS ESPECÍFICOS*

MODELO
ITERATIVO


CASCATA OU
CLÁSSICO

MODELO

COMPONENTES

ESPIRAL
PROTOTIPAGEM

EXPLORATÓRIA/ M THROW-AWAY/
EVOLUCIONÁRIA DESCARTÁVEL

Por fim, existe mais um conceito importante nessa aula! É o conceito de
Metodologia de
Desenvolvimento de Software (também chamada de Processo de Desenvolvimento de Software).
O que é isso, professor? É basicamente uma caracterização prescritiva ou descritiva de como um
produto de software deve ser desenvolvido, isto é, ela define o quê, como e quando
fazer algo
para desenvolver um software. Calma, tudo ainda fará sentido...

(CGU - 2012) A escolha de um modelo é fortemente dependente das características do
projeto. Os principais modelos de ciclo de vida podem ser agrupados em três categorias
principais:

a) sequenciais, cascata e evolutivos.

b) sequenciais, incrementais e ágeis.

c) sequenciais, incrementais e evolutivos.

d) sequenciais, ágeis e cascata.

e) cascata, ágeis e evolutivos.

Comentários: a maioria dos processos de software é baseada em três modelos gerais:
modelo em cascata; desenvolvimento
iterativo e engenharia de software baseada em componentes. Isso entra em contradição com 0 que
dizem outros autores, isto
é, os principais modelos podem ser agrupados em três categorias: modelos sequenciais,
modelos incrementais e modelos
evolutivo (Letra C).


Modelos Sequenciais

Modelo em Cascata

INCIDÊNCIA EM PROVA: ALTÍSSIMA


MODELOS SEQUENCIAIS

PRINCIPAIS MODELOS

MODELOS ESPECÍFICOS*


CASCATA OU
CLÁSSICO

MODELO
EM V

MODELO ITERATIVO

MÉTODOS
FORMAIS

BASEADO EM
COMPONENTES

5CRUM


XP METODOLOGIAS MODELO INCREMENTAL
MODELO EVOLUTIVO

ESPIRAL

PROTOTIPAGEM

TDD/ATDD SI


EXPLORATÓRIA/
EVOLUCIONÁRIA

THROW-AWAY/
DESCARTÁVEL

Citado inicialmente em 1970 por W. Royce, é também denominado Modelo em Cascata,
Clássico,
Sequencial, Linear, Tradicional, Waterfall, Rígido, Top-Down ou Monolítico (todos esses
nomes já
caíram em prova!). Esse nome é devido ao encadeamento simples de uma fase com a
outra. No
Modelo em Cascata, uma fase só se inicia após o término e aprovação da fase
anterior, isto é,
há uma sequência de desenvolvimento do projeto.

Como assim, Diego? Por exemplo: a Fase 4 só pode ser iniciada após o término e aprovação da Fase
3; a Fase 5 só pode ser iniciada após o término e aprovação da Fase 4; e assim por diante!

FASE 5

FASE 6


(TCE/TO - 2008) No ciclo de vida em cascata, é possível realizar alternadamente e
simultaneamente as atividades de desenvolvimento de software.

Comentários: no modelo em cascata, uma fase só se inicia após 0 término e aprovação da fase
anterior, isto é, há uma sequência
de desenvolvimento do projeto (Errado).

Mas que fases são essas, Diego?Bem, agora complica um pouco porque cada autor resolve criar suas
próprias fases! Vejam só na tabelinha a seguir:

POR SOMMERVILLE | POR ROYCE POR PRESSMAN (^ED)
| POR PRESSMAN (6* ED)


Análise e Definição de
Requisitos

Projeto de Sistema e
Software

Requisitos de Sistema Modelagem e Engenharia
do Sistema/lnformação

Requisitos de Software Análise de Requisitos de

Software

Comunicação

Planejamento


Implementação e Teste de
Unidade

Integração e Teste de
Sistema

Análise Projeto Modelagem

Projeto Geração de Código Construção


Operação e Manutenção Codificação Teste e
Manutenção

Implantação

Teste
Operação

Percebam que há grandes diferenças entre os autores! Inclusive, há divergências até
entre autor
e ele mesmo, dependendo da versão do livro (Exemplo: Pressman mudou as fases na
última edição
de seu livro). Professor, você já viu isso cair em prova? Sim, já vi! E o que aconteceu? Bem,
polêmica,
recursos, etc - não há o que fazer! Enfim... a minha classificação preferida é a do
Royce por conter
as fases que eu acho que realmente ocorrem no desenvolvimento de um software.

De toda forma, é interessante saber a visão dos dois autores mais consagrados. De
acordo com lan
Sommerville, o modelo em cascata é um exemplo de um processo dirigido a planos. Como
assim,
Diego? Ele quer dizer que, em princípio, você deve planejar e programar todas as
atividades do
processo antes de começar a trabalhar nelas. Os principais estágios do modelo em
cascata
refletem diretamente as atividades fundamentais do desenvolvimento:


FASES (IAN
SOMMERVILLE)

ANÁLISE E
DEFINIÇÃO DE
REQUISITOS

Os serviços, restrições e metas do sistema são estabelecidos por meio de consulta aos
usuários.
Em seguida, são definidos em detalhes e funcionam como uma especificação do sistema.


PROJETO DE
SISTEMA E
SOFTWARE

IMPLEMENTAÇÃO

ETESTE
UNITÁRIO

INTEGRAÇÃOE

TESTE DE
SISTEMA

OPERAÇÃOE
MANUTENÇÃO

O processo de projeto de sistemas aloca os requisitos tanto para sistemas de hardware como para
sistemas de software, por meio da definição de uma arquitetura geral do sistema. O
projeto de
software envolve identificação e descrição das abstrações fundamentais do sistema de
software
e seus relacionamentos.

Durante esse estágio, o projeto do software é desenvolvido como um conjunto de
programas ou
unidades de programa. O teste unitário envolve a verificação de que cada unidade
atenda a sua
especificação.

As unidades individuais do programa ou programas são integradas e testadas como um
sistema
completo para assegurar que os requisitos do software tenham sido atendidos. Após o
teste, o
sistema de software é entregue ao cliente.

Normalmente (embora não necessariamente), essa é a fase mais longa do ciclo de vida. O sistema
é instalado e colocado em uso. A manutenção envolve a correção de erros que não foram
descobertos em estágios iniciais do ciclo de vida, com melhora da implementação das
unidades
do sistema e ampliação de seus serviços em resposta às descobertas de novos requisitos.

Definição
de requisitos

Projeto de sistema
e software

Implementação
e teste unitário

Integração e
teste de sistema

Operação e
manutenção

Ainda de acordo com lan Sommerville, em princípio, o resultado de cada estágio é a
aprovação
de um ou mais documentos (assinados). O estágio seguinte não deve ser iniciado até
que a fase
anterior seja concluída. Na prática, esses estágios se sobrepõem e alimentam uns aos
outros de
informações. Durante o projeto, os problemas com os requisitos são
identificados; durante a
codificação, problemas de projeto são encontrados e assim por diante.

Logo, na prática, o processo de software não é um modelo linear simples, mas envolve
o feedback
de uma fase para outra. Dessa forma, os documentos produzidos em cada fase podem ser
modificados para refletirem as alterações feitas em cada um deles. Eventualmente, por
causa
dos custos de produção e aprovação de cada um dos documentos, as iterações
podem ser
dispendiosas e envolver um significativo retrabalho.


Após um pequeno número de iterações, é normal se congelarem partes do desenvolvimento,
como
a especificação, e dar-se continuidade aos estágios posteriores de desenvolvimento. A
solução dos
problemas fica para mais tarde, ignorada ou programada, quando possível. Esse
congelamento
prematuro pode significar que o sistema não fará o que o usuário quer e pode levar
a sistemas mal
estruturados, quando os problemas de projeto são contornados por artifícios de implementação.

Durante o estágio final do ciclo de vida (operação e manutenção), o software é
colocado em uso.
Erros e omissões nos requisitos originais do software são descobertos. Os erros de
programa e
projeto aparecem e são identificadas novas necessidades funcionais. O sistema deve
evoluir para
permanecer útil. Fazer essas alterações (manutenção do software) pode implicar
repetição de
estágios anteriores do processo.

O modelo em cascata é consistente com outros modelos de processos de
engenharia, e a
documentação é produzida em cada fase do ciclo. Assim, o processo torna-se visível, e
os gerentes
podem monitorar o progresso de acordo com o plano de desenvolvimento. Seu maior
problema é
a divisão inflexível do projeto em estágios distintos. Os compromissos devem ser
assumidos em
um estágio inicial do processo, o que dificulta que atendam às mudanças de requisitos dos clientes.

Em princípio, o modelo em cascata deve ser usado apenas quando os requisitos são bem
compreendidos e pouco provavelmente venham a ser radicalmente alterados durante
o
desenvolvimento do sistema. No entanto, ele reflete o tipo de processo usado em outros
projetos
de engenharia. Como é mais fácil usar um modelo de gerenciamento comum para todo o
projeto,
processos de software baseados no modelo em cascata ainda são comumente utilizados.

Já de acordo com Roger Pressman, há casos em que os requisitos de um problema são
bem
compreendidos - quando o trabalho flui da comunicação ao emprego de forma relativamente
linear. Essa situação ocorre algumas vezes quando adaptações ou aperfeiçoamentos bem
definidos
precisam ser feitos em um sistema existente. Por exemplo: uma adaptação em software
contábil
exigida devido a mudanças nas normas governamentais.

Pode ocorrertambém em um número limitado de novos esforços de desenvolvimento, mas
apenas
quando os requisitos estão bem definidos e são razoavelmente estáveis. O modelo em
cascata
sugere uma abordagem sequencial e sistemática para o desenvolvimento de software,
começando
com o levantamento de necessidades por parte do cliente, avançando pelas fases de
planejamento,
modelagem, construção, emprego e culminando no suporte contínuo do software concluído.


O modelo cascata tem sofrido diversas críticas a que fizeram com que até mesmo seus
mais
ardentes defensores questionassem sua eficácia. Entre os problemas encontrados, temos:

Projetos reais raramente seguem o fluxo sequencial que o modelo propõe. Embora o
modelo
linear possa conter iterações, ele o faz indiretamente. Como consequência, mudanças podem
provocar confusão à medida que a equipe de projeto prossegue.

Frequentemente, é difícil para o cliente estabelecer explicitamente todas as
necessidades. O
modelo cascata requer isso e tem dificuldade para adequar a incerteza natural que
existe no
início de muitos projetos.

O cliente deve ter paciência. Uma versão operacional do(s) programa(s) não estará
disponível
antes de estarmos próximos do final do projeto. Um erro grave, se não
detectado até o
programa operacional ser revisto, pode ser desastroso.

Em uma interessante análise de projetos reais, descobriu-se que a natureza linear do
ciclo de vida
clássico conduz a "estados de bloqueio", nos quais alguns membros da equipe do projeto
têm de
aguardar outros completarem tarefas dependentes. De fato, o tempo gasto na
espera pode
exceder o tempo gasto em trabalho produtivo! Os estados de bloqueio tendem a
prevalecer no
início e no final de um processo sequencial linear.

Hoje em dia, o trabalho de software tem um ritmo acelerado e está sujeito a
uma cadeia de
mudanças intermináveis (em características, funções e conteúdo de informações). O
modelo
cascata é frequentemente inapropriado para tal trabalho. Entretanto, ele pode servir
como um
modelo de processo útil em situações nas quais os requisitos são fixos e o trabalho
deve ser
realizado até sua finalização de forma linear.

É importante destacar que o desenvolvimento não continua até que o cliente esteja
satisfeito
com os resultados alcançados e isso engessa o desenvolvimento.

Tempo

0 MODELO EM CASCATA ATRASA A REDUÇÃO DE RISCOS


O Modelo em Cascata tem um grande problema: ele atrasa a redução de riscos! Como
assim, Diego?
Bem, essa é uma desvantagem recorrente em provas! Como uma fase só se inicia após o
término e
aprovação da fase anterior, em geral só é possível verificar se ocorreram erros nas
fases finais,
que é quando o sistema é efetivamente testado - isso gera grandes riscos! Em outros
modelos,
os riscos são reduzidos desde as primeiras fases do processo de desenvolvimento.

Percebam que os riscos deveriam ser descobertos logo no início do processo de
desenvolvimento,
no entanto eles são descobertos somente após o início dos testes e implantação. Vocês
podem
notar no gráfico acima que, a partir da região vermelha, o progresso do projeto sobe
e desce
diversas vezes, porque provavelmente o sistema está sendo corrigido devido a
requisitos
modificados. Descobriu um erro? Desce! Corrigiu o erro? Sobe!

Vejam, também, que o projeto não terminou em seu deadline (prazo de conclusão)
original.
Como a redução de riscos atrasou, todo andamento do projeto também atrasou. Dessa
forma, não
se cumpriu nem o prazo do projeto e, provavelmente, nem o orçamento e talvez nem seu
escopo -
tendo em vista que, quanto mais ao fim do projeto um erro é identificado, mais caras
se tornam as
modificações.

Entenderam essa parte direitinho? Um erro na fase de requisitos, por exemplo, que não
foi
corrigido e foi descoberto no final do processo de desenvolvimento, terá um custo de
correção
altíssimo, visto que provavelmente terá que se refazer tudo novamente. Vocês conhecem a
Torre de
Pisa? Ela fica na Itália e é famosa por ser torta. Respondam: seria mais fácil
corrigir a torre logo no
início da construção do primeiro andar ou no último?

Ora, se alguém tivesse notado que a torre estava torta logo no início da
construção do primeiro andar, seria possível corrigi-la sem ter tanto
trabalho! Agora se somente ao final da construção alguém notasse que a
torre estava bastante torta, seria muito mais trabalhoso e caro para
corrigir. Concordam comigo? A mesma coisa acontece com um software!
Se o cliente me pede uma coisa, mas eu entendo outra e somente mostro
para ele quando estiver tudo pronto, é evidente que eu estou atrasando a
redução de riscos. Por que? Porque se eu tivesse mostrado para ele cada
passo do desenvolvimento desde o início, ele poderia identificar o erro de
forma que eu pudesse corrigi-lo tempestivamente. Em outras palavras,
eu teria adiantado a redução de riscos - eu estaria reduzindo os riscos
de fazer algo errado de maneira adianta! Sacaram?

Portanto, não confundam essas duas coisas: se o erro ocorreu no início e foi identificado no início,
terá baixo custo de correção; se o erro ocorreu no início e foi identificado no final, terá alto
custo
de correção. Dessa forma, o custo de correção de um erro está mais focado no momento
em que
um erro é identificado do que no momento em que ele de fato ocorreu. Vocês
entenderam legal?
Então, vamos seguir...


Outra maneira de visualizar o atraso é por meio de um gráfico
Risco x Tempo, comparando o modelo em cascata com o
Modelo Iterativo e Incremental (que veremos a seguir).
Observem que o Modelo Iterativo e Incremental já começa a
reduzir os riscos desde o início do processo de
desenvolvimento, em contraste com o Modelo em Cascata
que acumula os riscos até a fase de testes, integração e
implantação do sistema. Vejam o gráfico ao lado e tentem
entender essa interpretação que acabamos de ver!

/\

i A ELD Eh CASCAÍAX

IFEPATÍVO E |NQ?€NEKnA^x.

TfeMFQ _ '

Galera, a grande vantagem do Modelo em Cascata é que o desenvolvimento é dividido em
fases
distintas, padronizadas, entre outras. Vantagem, professor? Em relação ao que existia
antes, sim!
Antigamente, os softwares eram construídos quase que de maneira artesanal. Ademais, é
possível
colocar pessoas com perfis específicos para cada fase, isto é, quem tem
facilidade de se
comunicar vai ser analista de requisitos, programadores vão fazer a codificação, etc.

A grande desvantagem é que - em projetos complexos - demora-se muito para chegar até
a fase
de testes, sendo que o cliente não vê nada rodando até a implantação. Então, pode
acontecer de,
nas fases finais, os requisitos da organização não serem mais os mesmos daqueles do início e o
software não ter mais utilidade para organização. Imaginem que vocês contratam um
pedreiro
para construir a casa de vocês.

Só que ele não vai te mostrar nada de como a casa está ficando, ele só vai te
mostrar quando já
estiver tudo pronto daqui um ano. É interessante? Não! Primeiro, porque você
vai morrer de
ansiedade. Segundo, porque isso atrasará a redução de riscos, aumentando a
probabilidade de
erros graves. Terceiro, porque demora tanto que durante esse ano você pode ter mudado
de ideia

-queria uma casa de um andare mudou de ideia para uma casa de dois andares, por exemplo.

Então o Modelo em Cascata não deve ser usado em nenhuma hipótese? Calma lá, ele pode
ser
utilizado, sim - apesar de atualmente ser bem raro! No entanto, sua
utilização deve ocorrer
preferencialmente quando os requisitos forem bem compreendidos e houver
pouca
probabilidade de mudanças radicais durante o desenvolvimento do sistema. Vocês entenderam?
Então vamos ver agora uma lista com as maiores vantagens e desvantagens.


VANTAGENS

É simples de entender e fácil de aplicar, facilitando o
planejamento.

Fixa pontos específicos para a entrega de artefatos.
Funciona bem para equipes tecnicamente fracas.

É fácil de gerenciar, devido a sua rigidez.

DESVANTAGENS

Divisão inflexível do projeto em estágios distintos.
Dificuldade em incorporar mudanças de requisitos.

Clientes só visualizam resultados próximos ao final do
projeto.

Atrasa a redução de riscos.


Realiza documentação extensa por cada fase ou
estágio.

Possibilita boa aderência a outros modelos de processo.

Funciona bem com projetos pequenos e com requisitos
bem conhecidos.

Apenas a fase final produz um artefato de software
entregável.

Cliente deve saber todos os requisitos no início do
projeto.

Modelo inicial (Royce) não permitia feedback entre as
fases do projeto.

Pressupõe que os requisitos ficarão estáveis ao longo do
tempo.

Não funciona bem com projetos complexos e 00,
apesar de compatível.

(MEC - 2011) O modelo Waterfall tem a vantagem de facilitar a realização de mudanças
sem a necessidade de retrabalho em fases já completadas.

Comentários: trata-se do exato oposto - há dificuldade de lidar com requisitos voláteis, tendo em
vista que dependendo do
erro, é necessário refazê-lo desde seu início (Errado).

Para finalizar, podemos afirmar que o Modelo em Cascata é considerado um método
tradicional
e fortemente prescritivo, isto é, ele busca sempre dizer o que fazer, em geral, por
meio de planos
definidos no início do projeto. Que planos, professor? Escopo, custo, cronograma... tudo
isso bem
detalhado em uma extensa documentação. Mudanças são bem-vindas? Claro que não! Mudanças
são bem-vindas no modelo do nosso próximo assunto...

Por fim, Roger Pressman trata de uma variação na representação do Modelo em Cascata
chamado Modelo em V, que descreve a relação entre ações de garantia da qualidade e as ações
associadas à comunicação, modelagem e atividades de construção iniciais. À medida que a
equipe de software desce em direção ao lado esquerdo do V, os requisitos básicos
do problema são
refinados em representações cada vez mais detalhadas e técnicas do problema e de sua solução.


Uma vez que o código tenha sido gerado, a equipe se desloca para cima, no lado
direito do V,
realizando basicamente uma série de testes (ações de garantia da qualidade) que validem
cada um
dos modelos criados à medida que a equipe se desloca para baixo, no lado
esquerdo do V.
Lembrando que os testes são executados do lado direito do Modelo em V, mas são
planejados do
lado esquerdo do Modelo em V.

(CFM - 2018) Em relação ao Modelo V de ciclo de vida de um software, assinale a
alternativa correta.

a) O referido modelo é dirigido portestes.

b) O planejamento de testes é realizado durante as fases de levantamento de requisitos,
design arquitetural e design detalhado.

c) É um modelo que trata a documentação como um artefato secundário.

d) Caracteriza-se como um modelo que tem foco primeiro na execução e depois na
correção dos bugs conforme aparecem. Por ser um modelo objetivo, não há
testes
referentes à arquitetura do sistema.

e) Trata-se de uma variação do Modelo Cascata e prevê uma fase de validação e de
verificação para cada fase de construção.

Comentários: (a) Errado, apesar de realizar testes a cada fase, ele não é dirigido a testes e, sim,
dirigido a planos; (b) Errado,
mas - honestamente - eu não vejo erro algum nesse item. Caso alguém saiba, favor me
contar; (c) Errado, é um artefato
primário; (d) Errado, ocorre uma correção de erros a cada fase da construção; (e) Correto.


Modelo Iterativo e Incremental

Conceitos Básicos

INCIDÊNCIA EM PROVA: ALTÍSSIMA

Como foi dito anteriormente, o Modelo em Cascata acumulava riscos e vários projetos
começaram
a fracassar um atrás do outro ao utilizá-lo no mundo inteiro. Diego, o que você quer
dizer com
fracassar? O projeto não era entregue, ou era entregue de forma completamente errada,
ou era
entregue faltando partes, ou era entregue no dobro do prazo combinado, ou era entregue
com o
dobro do custo acordado, enfim... diversos motivos!

Foi quando surgiu o Modelo Iterativo e Incremental como uma tentativa de resolver
esse
problema de acúmulo de riscos. Vejamos as diferenças fundamentais:

No Modelo em Cascata, caso haja cem requisitos, analisam-se os cem requisitos,
projetam-
se os cem requisitos, codificam-se os cem requisitos, testam-se os cem requisitos, e
assim
por diante sequencialmente;

No Modelo Incremental, caso haja cem requisitos, dividem-se os cem requisitos em
vinte
miniprojetos de cinco requisitos cada e utiliza-se o modelo em cascata para
cada
miniprojeto;

No Modelo Iterativo, caso haja cem requisitos, analisam-se, projetam-se,
codificam-se,
testam-se os cem requisitos, porém os requisitos são entregues incompletos e eu repito
esse
ciclo de refinamento até chegar ao produto final.

Sim, existe a abordagem incremental e a abordagem iterativa. No entanto, na prática
elas virão
sempre de forma combinada no modelo iterativo e incremental para
desenvolver os
miniprojetos e entregar partes diferentes do projeto. A imagem a seguir apresenta miniprojetos
sendo feitos iterativamente em um modelo iterativo e incremental. Observem que
cada iteração
(passagem pelas fases de desenvolvimento) refinam cada vez mais a funcionalidade.

PRIMEIRA ITERAÇÃO

... +

Dessa forma, os resultados são mais rápidos, há maior interação com o usuário e há
um feedback
mais intenso entre usuário e desenvolvedor - sendo possível reagir mais facilmente a
mudanças.
Essa abordagem permite gerenciamento e mitigação de riscos. Professor, mas eu fiquei
com uma
dúvida: qual é a diferença entre a abordagem iterativa e abordagem incremental? Ou
eles são
exatamente a mesma coisa?

Bem, galera... eu nunca vi até hoje em mais de dez anos no mundo de concursos
nenhuma
prova cobrar essa diferença entre modelo iterativo e modelo incremental! Como
eu disse,
quando se fala em modelo iterativo, já se presume que é incremental; e quando se
fala em modelo
incremental, já se presume que é iterativo. Eles frequentemente andam lado a
lado, mas há
pequenas diferenças.

INDO MAIS

FUNDO!

Cuidado com a grafia das palavras iterativo e interativo! Eu já as vi utilizadas de forma
invertida dezenas de vezes em provas e até em editais. Por vezes, bancas não acatam os
recursos contra isso! De todo modo, saibam que: iterativo = reiterado ou repetitivo;
interativo = participação ou ação mútua.

E se cair essa diferença em prova? Ora, caso caia em prova, a diferença é que, no
modelo
incremental, há várias equipes desenvolvendo uma parte do software a serem integradas
ao final
do desenvolvimento. Já no modelo iterativo, lança-se a versão 1.0, adicionam-se algumas
funcionalidades; lança uma versão 2.0, adicionam-se mais algumas funcionalidades;
e assim por
diante. Vejamos isso mais claramente utilizando o clássico exemplo da Monalisa...

Modelo Incremental: observem que a imagem mostra um artista com uma ideia completa já
sobre
o quadro em sua cabeça, mas ele desenvolve cada parte do quadro separadamente até
integrar as
partes em uma imagem completa. É como se fosse um quebra-cabeças em que cada parte é
entregue funcionando e depois integrada. Ele produz builds, isto é, partes do software.


Modelo Iterativo: observem que a imagem mostra um artista com um esboço do quadro,
sendo
que ele desenvolve várias versões até chegar ao resultado final que ele deseja. É como se fosse uma
visão abstrata da imagem, que em seguida vai sendo melhorada até chegar a uma visão
mais
concreta. Ele produz releases, isto é, versões constantemente melhoradas do software.

Uma das vantagens do modelo iterativo e incremental é que o cliente pode receber e
avaliar as
entregas do produto mais cedo, já no início do desenvolvimento do software. Além
disso, há
maiortolerância a mudanças com consequência direta de redução do risco de falha do
projeto, isto
é, ele acomoda melhor mudanças - aumentando o reúso e a qualidade. Lembram do exemplo
do
pedreiro e da casa? Vale o mesmo aqui...

E como é a abordagem dos nossos autores consagrados? lan Sommerville afirma
que o
desenvolvimento incremental é baseado na ideia de desenvolver uma implementação inicial,
expô-la aos comentários dos usuários e continuar por meio da criação de várias versões até que
um sistema adequado seja desenvolvido. Atividades de especificação,
desenvolvimento e
validação são intercaladas, e não separadas, com rápido feedback entre todas as atividades.

Desenvolvimento incremental é uma parte fundamental de abordagens ágeis - é
melhor que a
abordagem em cascata para a maioria dos sistemas de negócios, e-commerce e sistemas
pessoais.
Desenvolvimento incremental reflete a maneira como resolvemos os problemas.
Raramente
elaboramos uma completa solução do problema com antecedência; geralmente
movemo-nos
passo a passo em direção a uma solução, recuando quando percebemos que cometemos um erro.


Ao desenvolver um software de forma incremental, é mais barato e mais fácil fazer
mudanças no
software durante seu desenvolvimento. Cada incremento/versão do sistema incorpora
alguma
funcionalidade necessária para o cliente. Em geral, incrementos iniciais incluem a
funcionalidade
mais importante ou mais urgente. Isso significa que o cliente pode avaliar o sistema
em um estágio
relativamente inicial do desenvolvimento para ver se ele oferece o que foi requisitado.

Em caso negativo, só o incremento que estiver em desenvolvimento no momento precisará
ser
alterado e, possivelmente, nova funcionalidade deverá ser definida para
incrementos posteriores.
O desenvolvimento incremental tem três vantagens importantes quando comparado ao
modelo
em cascata: (1) o custo de acomodar as mudanças nos requisitos do cliente é reduzido.
A quantidade
de análise e documentação a ser refeita é muito menor do que o necessário no modelo em cascata;

(2) É mais fácil obter feedback dos clientes sobre o desenvolvimento que foi feito.
Os clientes
podem fazer comentários sobre as demonstrações do software e ver o quanto foi
implementado.
Os clientes têm dificuldade em avaliar a evolução por meio de documentos de projeto de software.

(3) É possível obter entrega e implementação rápida de um software útil ao cliente,
mesmo se toda
a funcionalidade não for incluída - 0 que é melhor do que seria com um processo em cascata.

O desenvolvimento incremental, atualmente, é a abordagem mais comum para o
desenvolvimento
de sistemas. Ele pode ser tanto dirigido a planos, ágil, ou, o mais comum, uma
mescla dessas
abordagens. Em uma abordagem dirigida a planos, os incrementos do sistema são
identificados
previamente; se uma abordagem ágil for adotada, os incrementos iniciais são
identificados, mas o
desenvolvimento de incrementos posteriores depende do progresso e das prioridades dos
clientes.

Bem, sabemos que a abordagem evolucionária é mais eficaz que abordagem em cascata. Por
que? Porque a especificação pode ser desenvolvida de forma incremental e, não,
integralmente
como naquele modelo. À medida que os usuários compreendem melhor seu problema, isso
pode
ser refletido no sistema de software. No entanto, essa abordagem possui dois
problemas (que,
inclusive, já caíram no Senado Federal):

a) O processo não é visível: se os sistemas são desenvolvidos rapidamente,
não é viável
economicamente produzir documentos para cada versão do sistema.

b) Os sistemas são frequentemente mal estruturados: mudanças contínuas tendem a corromper
a estrutura do software e tornar mudanças difíceis e caras.

(Senado Federal - 2013) No modelo evolucionário, a mudança constante tende a
corromper a estrutura do software.

Comentários: mudanças constantes acabam mexendo na estrutura do software, o que realmente tende a
corrompê-la
(Correto).


Os problemas do desenvolvimento incremental são particularmente críticos para os
sistemas de
vida-longa, grandes e complexos, nos quais várias equipes desenvolvem diferentes
partes do
sistema. Sistemas de grande porte necessitam de um framework/arquitetura
estável, e as
responsabilidades das equipes de trabalho do sistema precisam serclaramente definidas.
Isso deve
ser planejado com antecedência e não desenvolvido de forma incremental.

Você pode desenvolver um sistema de forma incremental e expô-lo aos
comentários dos
clientes, sem realmente entregá-lo e implantá-lo no ambiente do cliente. Entrega e
implantação
incremental significa que o software é usado em processos operacionais reais. Isso nem
sempre é
possível, pois experimentações com o novo software podem interromper os processos
normais de
negócios.

Atividade simultâneas

Especificação


Descrição
do esboço

------------► Desenvolvimento

Validação

Um esboço simples do processo de desenvolvimento incremental é apresentado na
imagem
anterior. As atividades de especificação, desenvolvimento e validação são intercaladas,
em vez
de separadas, com feedback rápido que permeia as atividades. Desenvolve-se rapidamente
uma
implementação inicial do software (protótipo) a partir de especificações bastante
abstratas e são
feitas modificações de acordo com sua avaliação.

Cada versão do programa herda as melhores características das versões anteriores. Cada
versão é
refinada com base no feedback recebido dos clientes para produzir um sistema que
satisfaça
suas necessidades. Neste ponto, o sistema pode ser entregue ou pode ser
reimplementado
utilizando uma abordagem mais estruturada para aumentar a robustez e
a facilidade de
manutenções!

As atividades de especificação, desenvolvimento e validação são concorrentes e apresentam
um
forte feedback entre si, como mostra a imagem apresentada anteriormente. Já na visão
de Roger
Pressman, em várias situações, os requisitos iniciais do software são
razoavelmente bem
definidos, entretanto, devido ao escopo geral do trabalho de desenvolvimento, o uso de
um
processo puramente linear não é utilizado.

Pode ser necessário o rápido fornecimento de um determinado conjunto funcional aos
usuários,
para somente após esse fornecimento, refinar e expandir sua funcionalidade em versões de
software posteriores. Em tais casos, pode-se optar por um modelo de processo
projetado para
desenvolver o software de forma incremental. O modelo incremental combina
elementos dos
fluxos de processos lineares e paralelos.

Na imagem a seguir, o modelo incremental aplica sequências lineares, de forma
escalonada, à
medida que o tempo vai avançando. Cada sequência linear gera "incrementais"
(entregáveis /
aprovados / liberados) do software de maneira similar aos incrementais gerados por um
fluxo de
processos evolucionários (que veremos adiante). Vamos pensar, por exemplo, em um
software de
processamento de texto desenvolvido com o emprego do paradigma incremental.


0k)-


$

£


o
"O

«A

«A

u

Dí
0)

0)

"C
D

"Õ

c

.0

'C

c
D

| "I Comunicação

| ~~| Planejamento

| ~| Modelagem (análise, projeto)

| Construção (codificação, testes)

| | Emprego (entrega, realimentação ou feedback]

incremento n° 2

incremento n° 1

a entrega do
incremento n° n
entrega do

2o incremento
entrega do
n-ésimo incremento

Io incremento

Cronograma do Projeto

Ele poderia liberar funções básicas de gerenciamento de arquivos, edição e
produção de
documentos no primeiro incremento; recursos mais sofisticados de edição
e produção de
documentos no segundo; revisão ortográfica e gramatical no terceiro; e,
finalmente, recursos
avançados de formatação (layout) de página no quarto incremento. Deve-se notar que o
fluxo de
processos para qualquer incremento pode incorporar o paradigma da prototipação.

Quando se utiliza um modelo incremental, frequentemente, o primeiro incremento
é um
produto essencial. Isto é, as os requisitos básicos são atendidos, porém,
muitos recursos
complementares (alguns conhecidos, outros não) ainda não são entregues. Esse produto
essencial
é utilizado pelo cliente (ou passa por uma avaliação detalhada). Como
resultado do uso e/ou
avaliação, é desenvolvido um planejamento para o incremento seguinte.

O planejamento já considera a modificação do produto essencial para melhor se
adequar às
necessidades do cliente e à entrega de recursos e funcionalidades adicionais. Esse
processo é
repetido após a liberação de cada incremento, até que seja produzido o produto
completo. O
modelo de processo incremental tem seu foco voltado para a entrega de um produto
operacional
com cada incremento.


Os primeiros incrementos são versões seccionadas do produto final, mas eles realmente
possuem
capacidade para atenderao usuário e também oferecem uma plataforma para avaliação do
usuário.
O desenvolvimento incremental é particularmente útil nos casos em que não há pessoal
disponível
para uma completa implementação na época de vencimento do prazo estabelecido para o
projeto.
Os primeiros incrementos podem ser implementados com número mais reduzido de pessoal.

Se o produto essencial for bem acolhido, então um pessoal adicional (se necessário) poderá ser
acrescentado para implementar o incremento seguinte. Além disso, os incrementos podem ser
planejados para administrar riscos técnicos. Por exemplo: um sistema importante
pode exigir a
disponibilidade de novo hardware que ainda está em desenvolvimento e cuja data de
entrega é
incerta.

Poderia ser possível planejar incrementos iniciais de modo a evitar o uso
desse hardware,
possibilitando a liberação de funcionalidade parcial aos usuários finais, sem um atraso excessivo.

(TRT/CE - 2017) Os modelos de processo em que o sistema é dividido em pequenos
subsistemas funcionais que, a cada ciclo, são acrescidos de novas funcionalidades são
denominados:

a) evolutivos.

b) unificados.

c) sequenciais.

d) incrementais.

Comentários: 0 modelo de processo que divide 0 sistema em pequenos subsistemas funcionais que, a
cada ciclo, são acrescidos
de novas funcionalidades é 0 modelo incremental (Letra D).


Rapid Application Development (RAD)

INCIDÊNCIA EM PROVA: MÉDIA

O RAD (Rapid Application Development) é um modelo iterativo e incremental, que enfatiza
o ciclo
de desenvolvimento curto (6o a 90 dias). Esse desenvolvimento ocorre tão
rápido, porque é
utilizada o reúso de componentes a exaustão. Como muitos componentes já estão testados,
pode-
se reduzir o tempo total de desenvolvimento. As fases são descritas na tabela seguinte
e exibidas
na imagem da próxima página:


FASES
MODELAGEM DE NEGÓCIO

MODELAGEM DE DADOS

MODELAGEM DE

PROCESSO

GERAÇÃO DA APLICAÇÃO

TESTE E MODIFICAÇÃO

DESCRIÇÃO

0 fluxo de informações entre as funções de negócio é modelado de modo a responder que
informação direciona o processo de negócio; que informação é gerada; quem gera essa
informação; para onde vai a informação gerada; e, porfim, quem processa a informação.

O fluxo de informação definido na fase de modelagem de negócio é refinado em um
conjunto de objetos de dados que são necessários para suportar o negócio. Os atributos
de cada objeto são identificados e os relacionamentos entre esses objetos são definidos.

Os objetos de dados definidos na modelagem de dados são transformados para conseguir

0 fluxo necessário para implementar uma função do negócio. Descrições do
processamento são criadas para adicionar, modificar, descartar ou recuperar um objeto
de dados.

Considera o uso de técnicas de quarta geração, trabalha com a reutilização de
componentes de programa existentes quando possível, ou cria componentes reusáveis.
São usadas ferramentas automatizadas para facilitar a construção do software.

Como 0 processo enfatiza o reúso, muitos componentes já estão testados e isso reduz o
tempo total de teste. No entanto, os novos componentes devem ser testados e todas as
interfaces devem ser exaustivamente exercitadas para colocar o resultado em produção.


Equipe #3

Detalhe interessante: as etapas de Modelagem de Negócio, Dados e Processos são
frequentemente
condensadas na etapa de Modelagem; e Geração da Aplicação, Teste e
Modificação são
frequentemente condensados na etapa de Construção. Lembrando que, como
pode ser
observado pela imagem apresentada anteriormente, essas etapas podem ser distribuídas por
diversas equipes.

Neste modelo, há uma interação direta e intensa com o usuário e uso frequente de
programação
de banco de dados e ferramentas de apoio ao desenvolvimento, como geradores
de telas e
relatórios. Mais abaixo, pode-se ver as vantagens e desvantagens do modelo de
desenvolvimento
rápido de aplicações. Galera, ele não pode ser utilizado em qualquer situação.
Recomenda-se
utilizá-lo em situações específicas.

Por exemplo: quando a aplicação não necessita de softwares auxiliares
(standalone); quando é
possível fazer uso de classes pré-existentes; quando a performance não é o
mais importante;
quando o risco técnico é reduzido; quando a distribuição do produto no mercado é
pequena; quando
o escopo do projeto é restrito; quando o sistema pode ser dividido em vários módulos;
quando o
risco de mudança tecnológica é baixo.


VANTAGENS

Permite o desenvolvimento rápido e/ou a prototipagem
de aplicações.

Criação e reutilização de componentes.

DESVANTAGENS

Exige recursos humanos caros e experientes.

O envolvimento com o usuário tem que ser ativo.


Desenvolvimento é conduzido em um nível mais alto de
abstração.

Grande redução de codificação manual com wizards.

Cada função pode ser direcionada para a uma equipe
separada.

Maior flexibilidade (desenvolvedores podem reprojetar
à vontade).

Provável custo reduzido (tempo é dinheiro e também
devido ao reuso).

Tempo de desenvolvimento curto.

Protótipos permitem uma visualização mais cedo.
Envolvimento maior do usuário.

Comprometimento da equipe do projeto.

Custo alto do conjunto de ferramentas e hardware para
rodara aplicação;

Mais difícil de acompanhar o projeto.

Perda de precisão científica (pela falta de métodos
formais).

Pode levar ao retorno das práticas caóticas no
desenvolvimento.

Pode construirfunções desnecessárias.

Requisitos podem não se encaixar (conflitos entre
desenvolvedores e clientes).

Padronização (aparência diferente entre os módulos e
componentes)

(IPEA/2003) O RAD (Rapid Application Development) é um modelo de processo de
software incremental que assume um ciclo de desenvolvimento curto e utiliza
uma
abordagem de construção com base em componentes.

Comentários: ele realmente é um modelo de processo incremental e ele-de fato-assume um
ciclo de desenvolvimento curso
com uma abordagem baseada em componentes (Correto).

(CONAB/2006) O modelo de processo de desenvolvimento de software incremental que
enfatiza um ciclo de desenvolvimento extremamente curto, que compreende asfases de
modelagem do negócio, modelagem dos dados, modelagem do processo, geração da
aplicação, além de teste e entrega, e que o desenvolvimento é conseguido pelo uso de
construção baseada em componentes, é conhecido como modelo:

a) sequencial linear;

b) RAD (Rapid Application Development);

c) de prototipagem;

d) espiral;

e) de desenvolvimento concorrente.

Comentários: desenvolvimento extremamente curto, modelo incremental, baseado em
componentes... só pode se referir ao
RAD (Letra B).


RESUMo

CICLO DE VIDA

ENGENHARIA DE SOFTWARE

DEFINIÇÕES DE CICLO DE VIDA

- TRATA-SE DAS FASES PELAS QUAIS ALGUMA COISA PASSA DESDE 0 SEU INÍCIO ATÉ 0 SEU FIM -

CICLO DE VIDA DE SOFTWARE

- TRATA-SE DAS FASES PELAS QUAIS UM SOFTWARE PASSA DESDE 0 SEU INÍCIO ATÉ 0 SEU FIM -

MODELO DE CICLO DE VIDA DE SOFTWARE

- TRATA-SE DAS FASES PELAS QUAIS UM SOFTWARE PASSA DESDE 0 SEU INÍCIO ATÉ 0 SEU FIM E COMO ESSAS
FASES SE RELACIONAM -

CICLOS DE VIDA GENÉRICOS


r k

IIMPLAMTA]ÇÃI

k J

r 1

cOMUNICAÇ]ÃI

k J

CICLO DE
VIDA (POR
PRESSMAN)

r 1

[IDNSTRUÇ] ÃI

k À


PROCESSOS DE SOFTWARE

CICLOS DE VIDA GENÉRICOS

- CONJUNTO DE ATIVIDADES, MÉTODOS, PRÁTICAS E TRANSFORMAÇÕES QUE GUIAM PESSOAS NA PRODUÇÃO DE
SOFTWARE -

MODELO DE PROCESSO DE SOFTWARE

- MESMO CONCEITO DE MODELO DE CICLO DE VIDA - É UMA REPRESENTAÇÃO ABSTRATA DE UM PROCESSO DE
SOFTWARE -

DESCRIÇÃO DE FASES GENÉRICAS

FASES | DESCRIÇÃO


O objetivo do planejamento de projeto é fornecer uma estrutura que possibilite ao
gerente fazer
estimativas razoáveis de recursos, custos e prazos. Uma vez estabelecido o escopo de software, com
um pequeno esboço dos requisitos, uma proposta de desenvolvimento deve ser elaborada, isto é, um
plano de projeto deve ser elaborado configurando o processo a ser utilizado no desenvolvimento de
software. À medida que o projeto progride, o planejamento deve ser detalhado e
atualizado
regularmente. Pelo menos ao final de cada uma dasfases do desenvolvimento (análise e especificação
de requisitos, projeto, implementação e testes), o planejamento como um todo deve ser revisto e o
planejamento da etapa seguinte deve ser detalhado. O planejamento e o acompanhamento do
progresso fazem parte do processo de gerência de projeto.

Nesta fase, o processo de levantamento de requisitos é intensificado. O escopo deve ser refinado e
os
requisitos mais bem definidos. Para entendera natureza do software a ser construído, o engenheiro
de software tem de compreender o domínio do problema, as restrições, as metas, as funcionalidades
e o comportamento esperados - ele pode o fazer por meio de diversas técnicas de levantamento de
requisitos (Ex: entrevistas). Uma vez capturados os requisitos do sistema a ser desenvolvido, estes
devem ser modelados, avaliados e documentados. Uma parte vital desta fase é a construção de um
modelo descrevendo o que o software tem de fazer (e não como fazê-lo).

Esta fase é responsável por incorporar requisitos tecnológicos aos requisitos essenciais do sistema,
modelados na fase anterior e, portanto, requer que a plataforma de implementação seja conhecida.
Basicamente, envolve duas grandes etapas: projeto da arquitetura do sistema e projeto detalhado. O
objetivo da primeira etapa é definir a arquitetura geral do software, tendo por base
o modelo
construído na fase de análise de requisitos. Essa arquitetura deve descrever a estrutura de nível
mais
alto da aplicação e identificar seus principais componentes. O propósito do projeto
detalhado é
detalharo projeto do software para cada componente identificado na etapa anterior. Os componentes
de software devem ser sucessivamente refinados em níveis maiores de detalhamento (inclusive em
relação à tecnologia adotada) até que possam ser codificados e testados.

O projeto deve ser traduzido para uma forma passível de execução pela máquina. A fase
de
implementação realiza esta tarefa, isto é, cada unidade de software do projeto
detalhado é
implementada.

Inclui diversos níveis de testes, a saber, teste de unidade, teste de integração e
teste de sistema.
Inicialmente, cada unidade de software implementada deve ser testada e os
resultados
documentados. A seguir, os diversos componentes devem ser integrados sucessivamente até se obter
o sistema. Finalmente, o sistema como um todo deve sertestado.

Uma vez testado, o software deve ser colocado em produção. Para tal, contudo, é necessário treinar
os usuários, configurar o ambiente de produção e, muitas vezes, converter bases de dados. O
propósito
desta fase é estabelecer que o software satisfaz os requisitos dos usuários. Isto é feito
instalando o
software e conduzindo testes de aceitação. Quando o software tiver demonstrado prover
as
capacidades requeridas, ele pode ser aceito e a operação iniciada.

Nesta fase, o software é utilizado pelos usuários no ambiente de produção, isto é, no ambiente real
de
uso do usuário.


Indubitavelmente, o software sofrerá mudanças após ter sido entregue para o usuário.
Alterações
ocorrerão porque erros foram encontrados, porque o software precisa ser adaptado para acomodar
mudanças em seu ambiente externo, ou porque o cliente necessita de funcionalidade
adicional ou
aumento de desempenho. Muitas vezes, dependendo do tipo e porte da manutenção necessária, essa
fase pode requerer a definição de um novo processo, onde cada uma das fases
precedentes é
reaplicada no contexto de um software existente ao invés de um novo.

PRINCIPAIS MODELOS DE DESENVOLVIMENTO


MODELOS
SEQUENCIAIS

PRINCIPAIS MODELOS MODELOS ESPECÍFICO


CASCATA OU
CLÁSSICO

MODELO

MODELO
ITERATIVO

COMPONENTES

5CRUM


MEIODOLOGIAS

XP

ÁGEIS

MODELO INCREMENTAL MODELO EVOLUTIVO

ESPIRAL

PROTOTIPAGEM

TDD/ATDD !

EVOLUCIONÁRIA DESCARTÁVEL

MODELOS EM CASCATA

POR SOMMERVILLE PORROYCE POR PRESSMAN (4* ED)
POR PRESSMAN (6« ED)


Análise e Definição de
Requisitos

Projeto de Sistema e
Software

Implementação e Teste de
Unidade

Integração e Teste de
Sistema

Requisitos de Sistema
Requisitos de Software
Análise

Projeto

Modelagem e Engenharia
do Sistema/lnformação
Análise de Requisitos de

Software

Projeto

Geração de Código

Comunicação
Planejamento
Modelagem

Construção


Operação e Manutenção Codificação
Teste

Operação

Teste e
Manutenção

Implantação


VANTAGENS

É simples de entender e fácil de aplicar, facilitando o
planejamento.

Fixa pontos específicos para a entrega de artefatos.
Funciona bem para equipes tecnicamente fracas.

É fácil de gerenciar, devido a sua rigidez.

DESVANTAGENS

Divisão inflexível do projeto em estágios distintos.
Dificuldade em incorporar mudanças de requisitos.

Clientes só visualizam resultados próximos ao final do
projeto.

Atrasa a redução de riscos.


Realiza documentação extensa por cada fase ou
estágio.

Possibilita boa aderência a outros modelos de processo.

Funciona bem com projetos pequenos e com requisitos
bem conhecidos.

Apenas a fase final produz um artefato de software
entregável.

Cliente deve saber todos os requisitos no início do
projeto.

Modelo inicial (Royce) não permitia feedback entre as
fases do projeto.

Pressupõe que os requisitos ficarão estáveis ao longo do
tempo.


Não funciona bem com projetos complexos e 00,
apesar de compatível.

MODELO ITERATIVO E INCREMENTAL

Modelo Incremental: observem que a imagem mostra um artista com uma ideia completa já
sobre
o quadro em sua cabeça, mas ele desenvolve cada parte do quadro separadamente até
integrar as
partes em uma imagem completa. É como se fosse um quebra-cabeças em que cada parte é
entregue funcionando e depois integrada. Ele produz builds, isto é, partes do software.

Modelo Iterativo: observem que a imagem mostra um artista com um esboço do quadro,
sendo
que ele desenvolve várias versões até chegar ao resultado final que ele deseja. É como se fosse uma
visão abstrata da imagem, que em seguida vai sendo melhorada até chegar a uma visão
mais
concreta. Ele produz releases, isto é, versões constantemente melhoradas do software.

PRIMEIRA ITERAÇÃO


SEGUNDA ITERAÇÃO

TERCEIRA ITERAÇÃO

...


Atividade simultâneas

Versão inicial


Descrição
do esboço

Versões
intermediárias

Versão final

RAPID APPLICATION DEVELOPMENT (RAD)

FASES | DESCRIÇÃO


MODELAGEM DE NEGÓCIO

O fluxo de informações entre as funções de negócio é modelado de modo a responder que
informação direciona o processo de negócio; que informação é gerada; quem gera essa
informação; para onde vai a informação gerada; e, porfim, quem processa a informação.


MODELAGEM DE DADOS

O fluxo de informação definido na fase de modelagem de negócio é refinado em um
conjunto de objetos de dados que são necessários para suportar o negócio. Os atributos
de cada objeto são identificados e os relacionamentos entre esses objetos são definidos.


MODELAGEM DE

PROCESSO

Os objetos de dados definidos na modelagem de dados são transformados para conseguir
o fluxo necessário para implementar uma função do negócio. Descrições do
processamento são criadas para adicionar, modificar, descartar ou recuperar um objeto
de dados.


GERAÇÃO DA APLICAÇÃO

Considera o uso de técnicas de quarta geração, trabalha com a reutilização de
componentes de programa existentes quando possível, ou cria componentes reusáveis.
São usadas ferramentas automatizadas para facilitar a construção do software.


TESTE E MODIFICAÇÃO

Como o processo enfatiza o reúso, muitos componentes já estão testados e isso reduz o
tempo total de teste. No entanto, os novos componentes devem ser testados e todas as
interfaces devem ser exaustivamente exercitadas para colocar o resultado em produção.


VANTAGENS

Permite o desenvolvimento rápido e/ou a prototipagem
de aplicações.

Criação e reutilização de componentes.

Desenvolvimento é conduzido em um nível mais alto de
abstração.

Grande redução de codificação manual com wizards.

Cada função pode ser direcionada para a uma equipe
separada.

DESVANTAGENS

Exige recursos humanos caros e experientes.

O envolvimento com o usuário tem que ser ativo.
Comprometimento da equipe do projeto.

Custo alto do conjunto de ferramentas e hardware para
rodara aplicação;

Mais difícil de acompanhar o projeto.


Maior flexibilidade (desenvolvedores podem reprojetar
à vontade).

Provável custo reduzido (tempo é dinheiro e também
devido ao reuso).

Tempo de desenvolvimento curto.

Protótipos permitem uma visualização mais cedo.
Envolvimento maior do usuário.

Perda de precisão científica (pela falta de métodos
formais).

Pode levar ao retorno das práticas caóticas no
desenvolvimento.

Pode construirfunções desnecessárias.

Requisitos podem não se encaixar (conflitos entre
desenvolvedores e clientes).

Padronização (aparência diferente entre os módulos e
componentes)


Equipe #1

Modelagem
de Negócios

Equipe #2

Modelagem
de Negócios

Modelagem
de Dados

Equipe #3

Modelagem
de Negócios

Modelagem n

Modelagem


Modelagem
de Dados

Modelagem
de Processos

Geraçao da
Aplicação

Modelagem
de Processos

Modificação

Geração da

Aplicação

Teste &

Modificação

PARA MAIS DICAS: WWW.INSTAGRAM.COM/PROFESSORDIEGOCARVALHO


QUESTõES CoMENTADAS - CESPE

í. (CESPE / BANRISUL - 2022) Um dos problemas da aplicação do modelo
cascata no
desenvolvimento de um projeto reside no fato de que uma versão operacional do programa
não
estará disponível antes que o projeto esteja perto do final, por conta do estado de
bloqueio que
a natureza linear do ciclo de vida clássico produz.

Comentários:

Perfeito! O modelo cascata segue uma abordagem linear de desenvolvimento de software,
onde
cada etapa tem que ser concluída antes de a próxima etapa começar. Isso significa
que, ao longo do
desenvolvimento, nenhuma versão operacional do programa estará disponível até que
o projeto
esteja próximo do final.

Gabarito: Correto

Item. 2. (CESPE / BANRISUL- 2022) O modelo cascata é frequentemente inadequado para os casos
de
desenvolvimento de soluções de software em que há ritmo acelerado e volume
intenso de
mudanças de características, todavia ele pode servir como um modelo de
processo útil em
situações nas quais os requisitos são fixos.

Comentários:

Perfeito! O Modelo em Cascata é projetado para trabalhar com requisitos fixos. Ele não
é ideal para
projetos que exigem mudanças frequentes, pois ele não é flexível o suficiente
para lidar com
mudanças. Ele também não é ideal para projetos de grande volume ou de ritmo
acelerado, pois o
processo é muito linear e demorado. Em projetos com requisitos fixos, no
entanto, o modelo
cascata pode ser útil porque permite gerenciar e controlar o processo de forma eficiente.

Gabarito: Correto

Item. 3. (CESPE / BANRISUL - 2022) O modelo do ciclo de vida clássico sugere
uma abordagem
sequencial para desenvolvimento de software, começando com a especificação dos requisitos
do cliente, avançando pelas fases de planejamento e modelagem, e culminando
no suporte
contínuo do software concluído.

Comentários:

Perfeito! O Modelo do Ciclo de Vida Clássico oferece uma abordagem
estruturada para o
desenvolvimento de software, a qual segue um conjunto de etapas comuns que
devem ser
cumpridas para garantir que o software desenvolvido atenda às necessidades do
cliente. Estas
etapas permitem que o desenvolvedor defina os requisitos específicos do cliente, crie
um plano
detalhado para o desenvolvimento do software e crie um produto final que atenda às necessidades
do cliente. Além disso, as etapas do modelo do ciclo de vida clássico também oferecem
suporte ao
longo do ciclo de vida do software desenvolvido para garantir que o produto
final atenda às
expectativas do cliente.

Gabarito: Correto

Item. 4. (CESPE / FUNPRESP-EXE - 2022) No modelo em espiral de desenvolvimento de software,
cada
giro ou loop da espiral representa uma fase do processo de software.

Comentários:

Perfeito! Vimos em aula que no modelo em espiral cada loop representa uma fase do
processo de
software. Dessa forma, o loop mais interno pode estar relacionado à
viabilidade do sistema; o
próximo loop, à definição de requisitos; o próximo, ao projeto de sistema e assim por
diante. Em
outras palavras, cada loop é uma fase e a fase é escolhida de acordo com as
necessidades do
negócio.

Gabarito: Correto

Item. 5. (CESPE / TJ-RJ - 2021) Na engenharia de software, pode-se dividir uma metodologia
genérica
em cinco macroatividades; entre elas, a que tem como objetivo criar um esboço do
projeto a ser
desenvolvido é:

a) o planejamento.

b) a modelagem.

c) o emprego.

d) a comunicação.

e) a construção.

Comentários:

Trata-se da fase (atividade) de modelagem. De acordo com Pressman: "Cria-se um
"esboço"para
que se possa ter uma ideia do todo - qual será o seu aspecto em termos de arquitetura, como as
partes
constituintes se encaixarão e várias outras características. Se necessário, refina-se o esboço com
mais
detalhes, numa tentativa de compreender melhor 0 problema e como resolvê-lo".

Gabarito: Letra B

Item. 6. (CESPE / Polícia Federal - 2021) Uma das etapas descritas em um método
desenvolvimento de
sistema clássico é a análise e definição de requisitos, etapa em que as restrições e
as metas do
sistema são obtidas por meio de consulta a usuários, com o objetivo de realizar a
especificação
do sistema.


Comentários:

Nesta fase, o escopo deve ser refinado e os requisitos mais bem definidos. Para
entender a natureza
do software a ser construído, o engenheiro de software tem de compreender o
domínio do
problema, as restrições, as metas, as funcionalidades e o comportamento esperados - ele
pode o
fazer por meio de diversas técnicas de levantamento de requisitos (Ex:
entrevistas). Uma vez
capturados os requisitos do sistema a ser desenvolvido, estes devem ser modelados,
avaliados e
documentados. Uma parte vital desta fase é a construção de um modelo descrevendo o
que o
software tem de fazer (e não como fazê-lo).

Gabarito: Correto

Item. 7. (CESPE / SERPRO - 2021) No modelo em cascata, dada a dificuldade natural para
estabelecer
todos os requisitos na fase inicial do projeto, os requisitos são definidos ao longo
de todas as
fases, acomodando-se gradualmente as incertezas e eventuais mudanças do projeto.

Comentários:

No modelo em cascata, todos os requisitos são levantados na fase inicial e, não, ao
longo das outras
fases. Essa definição seria adequada para metodologias ágeis!

Gabarito: Errado

Item. 8. (CESPE / SERPRO-2021) No modelo iterativo, as iterações na fase de construção
concentram-
se nas atividades de requisitos, gerenciamento, design e testes.

Comentários:

Um projeto que usa o desenvolvimento iterativo tem um ciclo de vida que
consiste em várias
iterações. Uma iteração incorpora um conjunto quase sequencial de tarefas em
modelagem de
negócio, requisitos, análise e design, implementação, teste e
implementação, em várias
proporções, dependendo do local em que ela está localizada no ciclo de
desenvolvimento. As
iterações nas fases de iniciação e de elaboração concentram-se nas atividades de
gerenciamento,
requisitos e design. As iterações na fase de construção concentram-se
no design, na
implementação e no teste. E as iterações na fase de transição concentram-se
no teste e na
implementação. As iterações devem ser gerenciadas em um estilo com caixa de hora, ou
seja, o
planejamento de uma iteração deve ser considerado fixo e o escopo do
conteúdo da iteração
gerenciado ativamente para atendera esse planejamento.

Gabarito: Errado

Item. 9. (CESPE / Ministério da Economia - 2020) Engenharia de software (ES) é um processo, expresso
como o conjunto de todas as atividades relacionadas ao desenvolvimento, ao controle, à
validação e à manutenção de um software operacional, abrangendo atividades
técnicas e
gerenciais.

Comentários:

Perfeito! Engenharia de Software é muito mais que apenas produzir software. Como afirma
Roger
Pressman, trata-se da aplicação de uma abordagem sistemática, disciplinada e
quantificável no
desenvolvimento, na operação e na manutenção de software; isto é, a aplicação de
engenharia ao
software. E como afirma lan Sommerville, a engenharia de software não está relacionada
apenas
com os processos técnicos de desenvolvimento de software, mas também com
atividades de
gerenciamento de projeto de software e desenvolvimento de ferramentas, métodos e teorias
que
apoiem a produção de software.

Gabarito: Correto
io.(CESPE / Ministério da Economia- 2020) Entre os modelos de processo
aplicados ao
desenvolvimento de software, o modelo cascata apresenta desvantagens por, entre
outros
motivos, não ter flexibilidade com requisitos, não produzir resultados tangíveis até a
fase de
codificação e dificultar o estabelecimento de requisitos completos antes de começar a codificar.

Comentários:

Questão um pouco estranha! Vejamos: (1) uma de suas desvantagens é que ele realmente
não
possui flexibilidade com requisitos - uma vez especificados, não podem ser modificados;
(2) uma
de suas desvantagens é que ele realmente não produz resultados tangíveis até a fase
de codificação,
mas eu salientaria que se trata de um resultado tangível para o usuário
(Ex: software em
funcionamento), visto que há outros resultados tangíveis, como artefatos
produzidos em cada
etapa; (3) uma de suas desvantagens é que ele realmente obriga que os
requisitos estejam
completos antes de começar a codificação e nós sabemos que requisitos podem se
modificar o
tempo todo.

Gabarito: Correto

Item. 11. (CESPE / TCE-RO - 2019) O modelo de desenvolvimento de sistemas cascata:

a) é voltado para requisitos de sistemas de software e, por isso, não engloba os
requisitos
de hardware.

b) prevê que os estágios sejam iniciados toda vez que a fase anteriortenha concluído
a etapa de
documentação.

c) envolve o feedback de uma fase para outra, por ser um modelo linear simples.


d) é sequencial, o que impede que os documentos produzidos em cada fase sejam
modificados
para refletirem as alterações feitas em cada um deles.

e) é consistente com outros modelos de processos de engenharia, apesar de haver uma
divisão
inflexível do projeto em estágios distintos.

Comentários:

(a) Errado, ele é utilizado para desenvolvimento de sistemas, que envolvem software e
hardware.
Além disso, engloba os requisitos não-funcionais, que podem tratar de requisitos de
hardware; (b)
Errado, não há obrigatoriamente uma documentação associada, apesar de ser o mais comum;
(c)
Errado, não se trata de um modelo linear simples - envolve uma sequência
de iterações das
atividades de desenvolvimento; (e) Correto.

Gabarito: Letra E

i2.(CESPE / EBSERH - 2018) O modelo de ciclo de vida em cascata tem como
características o
estabelecimento, no início do projeto, de requisitos de maneira completa, correta e
clara, e a
possibilidade de disponibilização de várias versões operacionais do software antes da
conclusão
do projeto.

Comentários:

O modelo de ciclo de vida em cascata realmente tem como característica o
estabelecimento, no
início do projeto, de requisitos de maneira completa, correta e clara. No entanto, não
há versões
operacionais do software antes da conclusão do projeto, apenas ao fim - essa é uma
característica
do modelo iterativo e incremental.

Gabarito: Errado
i3.(CESPE / IPHAN -2018) No modelo em cascata, com exceção do sequenciamento dos
estágios
de requisitos e de análise, os demais são executados em paralelo, iniciando-se antes
dotérmino
do estágio seguinte.

Comentários:

Na verdade, todos os estágios são sequenciais - não há exceção.

Gabarito: Errado

Item. 14. (CESPEITCE-PR - 2016 - Item B) A engenharia de software refere-se ao estudo das
teorias e
fundamentos da computação, ficando o desenvolvimento de software a cargo da
ciência da
computação.


Comentários:

A Engenharia de Software tem por objetivos a aplicação de teoria, modelos, formalismos,
técnicas
e ferramentas da ciência da computação e áreas afins para a desenvolvimento
sistemático de
software. Associado ao desenvolvimento, é preciso também aplicar processos,
métodos e
ferramentas sendo que a pedra fundamental que sustenta a engenharia de software é a
qualidade.
Conforme vimos em aula, não se trata do estudo - trata-se da aplicação.
Além disso, o
desenvolvimento também fica a cargo da engenharia de software. Em geral, a
ciência da
computação trata da teoria e a engenharia de software trata da prática.

Gabarito: Errado

Item. 15. (CESPE / TCE/PR - 2016 - Item E) O conceito de software se restringe ao
desenvolvimento do
código em determinada linguagem e seu armazenamento em arquivos.

Comentários:

Em uma visão restritiva, muitas pessoas costumam associar o termo software aos
programas de
computador. Software não é apenas o programa, mas também todos os dados de
documentação e
configuração associados, necessários para que o programa opere corretamente. O software
não é
apenas o programa, mas também todos os dados de documentação e configuração associados,
necessários para que o programa opere corretamente.

Gabarito: Errado

Item. 16. (CESPE / TCE-PR - 2016) As fases do ciclo de vida de um software são:

a) concepção, desenvolvimento, entrega e encerramento.

b) iniciação, elaboração, construção e manutenção.

c) escopo, estimativas, projeto e processo e gerência de riscos.

d) análise, desenvolvimento, teste, empacotamento e entrega.

e) planejamento, análise e especificação de requisitos, projeto, implementação, testes,
entrega
e implantação, operação e manutenção.

Comentários:

Alguns autores afirmam que os modelos de ciclo de vida básicos, de maneira geral,
contemplam
pelo menos as fases de: Planejamento; Análise e Especificação de
Requisitos; Projeto;
Implementação; Testes; Entrega e Implantação; Operação; e Manutenção. Logo, a
questão trata
da última opção.

Gabarito: Letra E


i7.(CESPE / TCE-PR - 2016 - Item A) A engenharia de software está relacionada aos
diversos
aspectos de produção de software e inclui as atividades de especificação,
desenvolvimento,
validação e evolução de software.

Comentários:

Sommerville afirma que um processo de software é um conjunto de atividades
e resultados
associados que produz um produto de software. De acordo com ele, existem
quatro atividades
fundamentais de processo, que são comuns a todos os processos de software -
são elas:
Especificação de Software; Desenvolvimento de Software (Projeto e Implementação);
Validação de
Software; e Evolução de Software. Dessa forma, a questão está correta.

Gabarito: Correto
i8.(CESPE / TCE-PR - 2016 - Item D) Um processo de software é composto por quatro
atividades
fundamentais: iniciação, desenvolvimento, entrega e encerramento.

Comentários:

Sommerville afirma que um processo de software é um conjunto de atividades
e resultados
associados que produz um produto de software. De acordo com ele, existem
quatro atividades
fundamentais de processo, que são comuns a todos os processos de software -
são elas:
Especificação de Software; Desenvolvimento de Software (Projeto e Implementação);
Validação de
Software; e Evolução de Software. Dessa forma, a questão está incorreta.

Gabarito: Errado
ig.(CESPE / TCE-PR - 2016) O modelo de desenvolvimento em cascata é utilizado em caso
de
divergência nos requisitos de um software, para permitir a evolução gradual do
entendimento
dos requisitos durante a implementação do software.

Comentários:

Essa questão trata, na verdade, do modelo iterativo e incremental e, não, em cascata.

Gabarito: Errado

2o.(CESPE / TCE-PR - 2016 - Item C) No modelo iterativo de desenvolvimento de
software, as
atividades são dispostas em estágios sequenciais.

Comentários:


A questão trata do modelo em cascata de desenvolvimento de software. No modelo
iterativo e
incremental, as atividades são dispostas ao longo de diversas iterações

Gabarito: Errado

Item. 21. (CESPE / STJ - 2015) Embora os engenheiros de software geralmente utilizem uma
abordagem
sistemática, a abordagem criativa e menos formal pode sereficiente em algumas
circunstâncias,
como, por exemplo, para o desenvolvimento de sistemas web, que requerem uma mistura de
habilidades de software e de projeto.

Comentários:

Galera, basta pensar nas metodologias ágeis! O que são metodologias ágeis? São
metodologias
menos formais e são mais adequadas em determinadas circunstâncias. Notem que isso não
vai de
encontro ao princípio da formalidade, na medida em que a questão deixa claro que se
trata de uma
abordagem "menosformal" e, não, "informal".

Além disso, isso consta também do livro do Sommerville: "No entanto, engenharia tem
tudo a ver
com selecionar 0 método mais adequado para um conjunto de circunstâncias, então uma
abordagem
mais criativa e menos formal pode ser eficiente em algumas circunstâncias.
Desenvolvimento menos
formal particularmente adequado para 0 desenvolvimento de sistemas Web, que
requerem uma
mistura de habilidades de software e de projeto".

Gabarito: Correto

22.(CESPE / STJ - 2015) O foco da engenharia de software inclui
especificação do sistema,
desenvolvimento de hardware, elaboração do projeto de componentes de hardware e software,
definição dos processos e implantação do sistema.

Comentários:

Na verdade, pode até tratar eventualmente de alguns aspectos de hardware; mas
desenvolvimento
de hardware, não.

Gabarito: Errado

Item. 23. (CESPE / STJ - 2015) As principais atividades de engenharia de software são
especificação,
desenvolvimento, validação e evolução.

Comentários:

Mais uma vez: Sommerville afirma que um processo de software é um conjunto de
atividades e
resultados associados que produz um produto de software. De acordo com ele, existem quatro
atividades fundamentais de processo, que são comuns a todos os processos de software -
são elas:
Especificação de Software; Desenvolvimento de Software (Projeto e Implementação);
Validação de
Software; e Evolução de Software.

A questão peca um pouco ao dizer que são atividades da engenharia de software. O
ideal seria dizer
que são as atividades principais do processo de software. Não sei se entraram com recurso e a banca
recusou e se não entraram com recurso. Percebam também que é a terceira vez esse
tipo de
questão cai em prova.

Gabarito: Correto

24.(CESPE /TCE-RO - 2013) Engenharia de software não está relacionada somente aos
processos
técnicos de desenvolvimento de softwares, mas também a atividades como gerenciamento de
projeto e desenvolvimento de ferramentas, métodos e teorias que apoiem a
produção de
softwares.

Comentários:

De acordo com Sommerville: "A engenharia de software não está relacionada
apenas com os
processos técnicos de desenvolvimento de software, mas também com
atividades como 0
gerenciamento de projeto de software e 0 desenvolvimento de ferramentas, métodos e
teorias que
apoiem a produção de software". Logo, a questão está perfeita!

Gabarito: Correto

25.(CESPE / TCE-RO - 2013) Assim como a Engenharia de Software, existe também na área
de
informática a chamada Ciência da Computação. Assinale a alternativa que melhor apresenta
a
diferença entre Engenharia de Software e Ciência da Computação.

a) A Ciência da Computação tem como objetivo o desenvolvimento
de teorias e
fundamentações. Já a Engenharia de Software se preocupa com as práticas de
desenvolvimento
de software.

b) A Engenharia de Software trata da criação dos sistemas de computação (softwares)
enquanto
a Ciência da Computação está ligada ao desenvolvimento e criação de
componentes de
hardware.

c) A Engenharia de Software trata dos sistemas com base em computadores,
que inclui
hardware e software, e a Ciência da Computação trata apenas dos aspectos de
desenvolvimento
de sistemas.


d) A Ciência da Computação trata dos sistemas com base em computadores,
que inclui
hardware e software, e a Engenharia de Software trata apenas dos
aspectos de
desenvolvimento de sistemas.

e) A Ciência da Computação destina-se ao estudo e solução para problemas genéricos das áreas
de rede e banco de dados e a Engenharia de Software restringe- se ao desenvolvimento
de
sistemas.

Comentários:

A Engenharia de Software tem por objetivos a aplicação de teoria, modelos, formalismos,
técnicas
e ferramentas da ciência da computação e áreas afins para a desenvolvimento
sistemático de
software. Associado ao desenvolvimento, é preciso também aplicar processos,
métodos e
ferramentas sendo que a pedra fundamental que sustenta a engenharia de software é a qualidade.

Essa questão parece contradizer o que diz Sommerville, mas não! A Engenharia de
Software coloca
em prática a teoria e fundamentação trazida pela Ciência da Computação. A
Engenharia de
Software aplica a teoria, mas - grosso modo - ela não tem a finalidade principal de
elaborá-la; a
finalidade principal é de colocá-la em prática. Já a Ciência da Computação
é exatamente o
contrário. Enfim, a primeira opção foi retirada literalmente do Sommerville (Pág. 5, 8a Ed.).

Gabarito: Letra A

26.(CESPE/TRTio-2Oi3) As atividades fundamentais relacionadas ao processo de construção de
um software incluem a especificação, o desenvolvimento, a validação e a evolução do software.

Comentários:

Sommerville afirma que um processo de software é um conjunto de atividades
e resultados
associados que produz um produto de software. De acordo com ele, existem
quatro atividades
fundamentais de processo, que são comuns a todos os processos de software -
são elas:
Especificação de Software; Desenvolvimento de Software (Projeto e Implementação);
Validação de
Software; e Evolução de Software. Logo, a questão está corretíssima!

Gabarito: Correto

27.(CESPE / TRT10 - 2013) O ciclo de vida de um software, entre outras
características, está
relacionado aos estágios de concepção, projeto, criação e implementação.

Comentários:

Essa questão é péssima! Ela foi retirada do livro Sistemas de Informação: Uma
Abordagem Gerencial

(Steven R. Gordon, Judith R. Gordon). Nesse livro, os autores de fato tratam o ciclo de vida de
software como concepção, projeto, criação e implementação. Essa é uma daquelas
quase
impossível de acertar! Esse não é um autor consagrado de Engenharia de Software.

Gabarito: Correto

28.(CESPE/TRT-i7-20i3) O objetivo do RAD é separar os modelos da visualização e do
controle.
Ele fornece o controlador e facilita a escrita de moldes padronizados para
a camada de
visualização.

Comentários:

Galera, esse item não faz qualquer sentido! Não é possível nem avaliar de tão errado...

Gabarito: Errado

2g.(CESPE / MEC - 2011) O processo de desenvolvimento de software é uma
caracterização
descritiva ou prescritiva de como um produto de software deve ser desenvolvido.

Comentários:

Metodologia de Desenvolvimento de Software É uma caracterização prescritiva ou
descritiva de
como um produto de software deve ser desenvolvido, isto é, define o quê, como e
quando fazer
algo - um exemplo clássico é o RUP! Segundo Pressman, um modelo prescritivo consiste
em um
conjunto específico de atividades de arcabouço, como - por exemplo - a NBR ISSO/IEC
12207, que
estabelece uma estrutura comum para os processos de ciclo de vida de software. Já um
modelo
descritivo apresenta o processo em detalhes, é como se fosse um guia para o
desenvolvimento de
software. Ambas as formas podem ser utilizadas.

Gabarito: Correto

3o.(CESPE / MEC - 2011) Atividades comuns a todos os processos de software
incluem a
especificação, o projeto, a implementação e a validação.

Comentários:

Sommerville afirma que um processo de software é um conjunto de atividades
e resultados
associados que produz um produto de software. De acordo com ele, existem
quatro atividades
fundamentais de processo, que são comuns a todos os processos de software -
são elas:
Especificação de Software; Desenvolvimento de Software (Projeto e Implementação);
Validação de
Software; e Evolução de Software.


Notem que o examinador dividiu a atividade de Desenvolvimento em Projeto e
Implementação,
mas não invalida a questão. Professor, ele não falou sobre a evolução! Sim, mas a
questão apenas
afirma que essas são atividades comuns e, não, que são as únicas.

Gabarito: Correto

3i.(CESPE / TJ-ES - 2011) Entre as etapas do ciclo de vida de software, as menos
importantes
incluem a garantia da qualidade, o projeto e o estudo de viabilidade. As demais
atividades do
ciclo, como a implementação e os testes, requerem maior dedicação da equipe e são essenciais.

Comentários:

Para a definição completa do processo, cada atividade descrita no modelo de ciclo de
vida deve ser
decomposta e para suas subatividades, devem ser associados métodos, técnicas,
ferramentas e
critérios de qualidade, entre outros, formando uma base sólida para o
desenvolvimento.
Adicionalmente, outras atividades, tipicamente de cunho gerencial, devem ser
definidas, como
controle e garantia da qualidade. Não existe uma hierarquia de etapas mais importantes
e menos
importantes!

Gabarito: Errado

Item. 32. (CESPE / TJ-ES - 2011) O modelo de processo incremental de desenvolvimento de
software é
iterativo, assim como o processo de prototipagem. Contudo, no processo
incremental,
diferentemente do que ocorre no de prototipagem, o objetivo consiste em
apresentar um
produto operacional a cada incremento.

Comentários:

De fato, no modelo iterativo e incremental, apresenta-se sempre um produto a cada
incremento.
Já na prototipação, não. Idealmente, ele serve apenas para identificar requisitos.

Gabarito: Correto

Item. 33. (CESPE / AL-ES - 2011) O ciclo de vida RAD (Rapid Application Development), por
privilegiar a
rapidez do desenvolvimento, não possui etapa de modelagem.

Comentários:

Como não? Existe Modelagem de Negócio, Dados e Processo!

Gabarito: Errado


34- (CESPE / DETRAN/ES - 2010) Segundo princípio da engenharia de software, os vários
artefatos
produzidos ao longo do seu ciclo de vida apresentam, de forma geral, nível de
abstração cada
vez menor.

Comentários:

Galera, vamos pensar um pouco! A abstração é a subtração de detalhes - focar-se no
que é mais
relevante e ignorar detalhes menos relevantes. No início do ciclo de vida, os
artefatos são bastante
abstratos. Temos, por exemplo, uma modelagem do negócio, um documento de
requisitos
funcionais, a abstração vai diminuindo eternos a modelagem visual de análise, depois a
modelagem
do projeto, até chegar ao código-fonte e ao executável do software. Nesse ponto, temos
o menor
nível de abstração (com muitos detalhes!). Compreenderam?

Gabarito: Correto

35.(CESPE/TRE-BA-2oIo) Entre os desafios enfrentados pela engenharia de software
estão lidar
com sistemas legados, atender à crescente diversidade e atender às exigências quanto a
prazos
de entrega reduzidos.

Comentários:

Bem, essa questão é bastante intuitiva. De fato, a engenharia de software
tem que lidar com
sistemas legados, atender à crescente diversidade e atender às exigências
quanto aos (curtos)
prazos de entrega.

Gabarito: Correto

36.(CESPE /TRE-BA-2010) Um modelo de processo de software consiste em uma representação
complexa de um processo de software, apresentada a partir de uma perspectiva genérica.

Comentários:

Um modelo de processo é uma representação abstrata de um esqueleto de processo,
incluindo
tipicamente algumas atividades principais, a ordem de precedência entre elas e,
opcionalmente,
artefatos requeridos e produzidos. Em geral, um modelo de processo descreve uma
filosofia de
organização de atividades, estruturando-as em fases e definindo como
essas fases estão
relacionadas. Logo, um modelo de processo de software ou modelo de ciclo de
vida trata da
representação abstrata/simplificada de um processo de software, apresentada a
partir de uma
perspectiva genérica.

Gabarito: Errado


37- (CESPE / EMBASA - 2010) Ciclo de vida de um software resume-se em eventos
utilizados para
definir o status de um projeto.

Comentários:

O ciclo de vida de software é um conjunto de estágios (e, não, eventos) utilizados
para definir o
status de um software (e, não, projeto). Sommerville afirma, por exemplo, que um ciclo
de vida é
composto por estágios que demonstram atividades fundamentais de desenvolvimento.
Questão
errada!

Gabarito: Errado

38.(CESPE / DETRAN-ES - 2010) Quando um aplicativo de software desenvolvido
em uma
organização atinge, no fim do seu ciclo de vida, a fase denominada
aposentadoria,
descontinuação ou fim de vida, todos os dados por ele manipulados podem ser descartados.

Comentários:


r

OPERAÇÃO

k À

CICLO DE
VIDA DE
SOFTWARE

PROJETO

r 1

TESTES

À

Essa questão é um absurdo! Observem que ela afirma "podem ser descartados". Ora, é
evidente que
podem ser descartados. No entanto, o gabarito oficial é errado!

Gabarito: Errado

39.(CESPE / BASA-2010) No modelo em cascata, o projeto segue uma série de passos
ordenados.
Ao final de cada projeto, a equipe de projeto finaliza uma revisão. O desenvolvimento
continua
e, ao final, o cliente avalia a solução proposta.

Comentários:

De acordo com Vasconcelos (2006), no Modelo em Cascata, o projeto segue uma série
passos
ordenados, ao final de cada fase, a equipe de projeto finaliza uma revisão.
Além disso, o
desenvolvimento não continua até que o cliente esteja satisfeito com os resultados alcançados. A


questão afirma que a equipe de projeto finaliza uma revisão ao final de cada projeto,
mas na
verdade é ao final de cada fase.

Gabarito: Errado

4O.(CESPE / ANAC - 2009) O termo engenharia pretende indicar que o
desenvolvimento de
software submete-se a leis similares às que governam a manufatura de produtos
industriais em
engenharias tradicionais, pois ambos são metodológicos.

Comentários:

Perfeito! A Engenharia busca os princípios mais consolidados de outras
engenharias mais
tradicionais - engenharia mecânica, civil, elétrica, etc.

Gabarito: Correto

Item. 41. (CESPE / TCE-TO - 2009 - Item A) Quanto maior e mais complexo o projeto de
software, mais
simples deve ser o modelo de processo a ser adotado.

Comentários:

Galera, não existe essa relação! Em geral, quanto mais complexo o projeto
mais complexo o
modelo. No entanto, isso também não é uma regra. Hoje em dia, existem projetos
megacomplexos
feitos utilizando metodologias ágeis, por exemplo.

Gabarito: Errado

42.(CESPE / TCE-TO - 2009 - Item B) O modelo de ciclo de vida do software serve
para delimitar
o alvo do software. Nessa visão, não são consideradas as atividades
necessárias e o
relacionamento entre elas.

Comentários:

A escolha de um modelo de ciclo de vida (para concursos, sinônimo de modelo de
processo) é o
ponto de partida para a definição de um processo de desenvolvimento de software. Um
modelo de
ciclo de vida, geralmente, organiza as macro-atividades básicas do processo,
estabelecendo
precedência e dependência entre as mesmas. Logo, o alvo do software serve
para delimitar o
modelo de ciclo de vida a ser escolhido. Primeiro, define-se o alvo do software para,
só então,
escolher o modelo de ciclo de vida mais adequado. Ademais, são consideradas
as atividades
necessárias e o relacionamento entre elas.

Gabarito: Errado


43-(CESPE / INMETRO - 2009) Em uma empresa que tenha adotado um
processo de
desenvolvimento de software em cascata, falhas no levantamento de requisitos
têm maior
possibilidade de gerar grandes prejuízos do que naquelas que
tenham adotado
desenvolvimento evolucionário.

Comentários:


VANTAGENS

É simples de entender e fácil de aplicar, facilitando o
planejamento.

Fixa pontos específicos para a entrega de artefatos.
Funciona bem para equipes tecnicamente fracas.

É fácil de gerenciar, devido a sua rigidez.

DESVANTAGENS

Divisão inflexível do projeto em estágios distintos.
Dificuldade em incorporar mudanças de requisitos.

Clientes só visualizam resultados próximos ao final do
projeto.

Atrasa a redução de riscos.


Realiza documentação extensa por cada fase ou
estágio.

Possibilita boa aderência a outros modelos de
processo.

Funciona bem com projetos pequenos e com
requisitos bem conhecidos.

Apenas a fase final produz um artefato de software
entregável.

Cliente deve saber todos os requisitos no início do
projeto.

Modelo inicial (Royce) não permitia feedback entre as
fases do projeto.

Pressupõe que os requisitos ficarão estáveis ao longo
do tempo.

Não funciona bem com projetos complexos e 00,
apesar de compatível.

O Modelo em Cascata, de fato, não reage bem a mudanças; já Modelo
evolucionário é mais
adaptável a mudanças por se utilizar de iterações.

Gabarito: Correto

44-(CESPE / INMETRO - 2009) Em um processo de desenvolvimento em cascata, os testes de
software são realizados todos em um mesmo estágio, que acontece após a finalização das
fases
de implementação.

Comentários:

POR SOMMERVILLE | POR ROYCE POR PRESSMAN (4? ED]
| POR PRESSMAN (63 ED] |


Análise e Definição de
Requisitos

Requisitos de Sistema Modelagem e Engenharia
do Sistema/lnformação

Comunicação


Projeto de Sistema e
Software

Requisitos de
Software

Análise de Requisitos de
Software

Planejamento


Implementação e Teste
de Unidade

Análise Projeto Modelagem


Integração e Teste de
Sistema

Operação e Manutenção

Projeto
Codificação
Teste
Operação

Geração de Código

Teste e
Manutenção

Construção
Implantação

Todos em um mesmo estágio, não. A grande maioria dos testes ocorrem, de fato, após a
finalização
das fases de implementação. No entanto, podem ocorrer testes unitários durante
a própria
implementação.

Gabarito: Errado

45.(CESPE / IPEA - 2009) No modelo em cascata de processo de desenvolvimento, os
clientes
devem definir os requisitos apenas durante a fase de projeto; e os
projetistas definem as
estratégias de projeto apenas durante a fase de implementação. As fases do
ciclo de vida
envolvem definição de requisitos, projeto, implementação, teste, integração,
operação e
manutenção. Em cada fase do ciclo de vida, podem ser produzidos diversos artefatos.

Comentários:

Essa questão não faz sentido! Os clientes definem os requisitos durante a fase de
Definição de
Requisitos. Já os projetistas definem as estratégias de projeto apenas durante a fase Projeto.

Gabarito: Errado

46.(CESPE - 2009 - INMTRO - Analista de Sistema) No desenvolvimento de software, o
modelo
em cascata é estruturado de tal maneira que as fases que compõem o desenvolvimento são
interligadas. Nessa situação, o final de uma fase implica o início de outra.

Comentários:

No Modelo em Cascata, uma fase só se inicia após o término e aprovação da fase
anterior, isto é,
há uma sequência de desenvolvimento do projeto. Por exemplo, a Fase 4 só é iniciada
após o
término e aprovação da Fase 3. A Fase 5 só é iniciada após o término e aprovação da Fase
Item. 4. Logo,
está em conformidade com a definição.

Gabarito: Correto

Item. 47. (CESPE / TRE-MT - 2009 - Item A) O modelo em cascata é apropriado para software
em que
os requisitos ainda não foram bem compreendidos, pois é focado na criação de incrementos.


Comentários:

A utilização do Modelo em Cascata deve ocorrer preferencialmente quando os
requisitos forem
bem compreendidos e houver pouca probabilidade de mudanças radicais
durante o
desenvolvimento do sistema. Logo, questão totalmente errada!

Gabarito: Errado

48.(CESPE / UNIPAMPA - 2009 - Item D) O modelo em cascata sugere uma
abordagem
sistemática e sequencial para o desenvolvimento de software. Sua natureza linear leva a
estados
de bloqueio nos quais, para que nova etapa seja iniciada, é necessário que a
documentação
associada à fase anterior tenha sido aprovada.

Comentários:

No Modelo em Cascata, uma fase só se inicia após o término e aprovação da fase
anterior, isto é,
há uma sequência de desenvolvimento do projeto. Por exemplo: a Fase 4 só é iniciada
após o
término e aprovação da Fase 3. A Fase 5 só é iniciada após o término e aprovação
da Fase 4. Não
basta terminar uma fase, é necessário que ela tenha sido aprovada.

Gabarito: Correto

4g.(CESPE / UNIPAMPA- 2009) No modelo de desenvolvimento incremental, a cada iteração
são
realizadas várias tarefas. Na fase de análise, pode ser feito o refinamento de
requisitos e o
refinamento do modelo conceituai.

Comentários:

Perfeito, é a fase seguinte à fase de requisitos e busca refiná-los.

Gabarito: Correto

5O.(CESPE / INPE - 2008) O ciclo de vida do software tem início na fase de projeto.

Comentários:

Mais uma vez: alguns autores afirmam que os modelos de ciclo de vida básicos, de
maneira geral,
contemplam pelo menos as fases de: Planejamento; Análise e Especificação de Requisitos;
Projeto;
Implementação; Testes; Entrega e Implantação; Operação; e Manutenção. Logo, ele não
começa
com projeto! Como você começa com projeto sem sequer levantar os requisitos?
Era possível
responder usando só lógica!

Gabarito: Errado


5i. (CESPE / TST- 2008) No modelo de desenvolvimento sequencial linear, a fase de
codificação
é a que gera erros de maior custo de correção.

Comentários:

Galera, erro na fase de requisitos que não foi corrigido e foi descoberto no final
do processo de
desenvolvimento, terá um custo de correção altíssimo, visto que provavelmente terá que
se refazer
tudo novamente. Ora, se eu peço a construção de um carro e você constrói uma moto,
o custo para
corrigir esse erro será altíssimo. Portanto não confundam essas duas coisas! Percebam o
que eu
disse: quanto mais tarde se descobre um erro, mais caro se torna sua correção.

Dizendo isso de outra forma: erros nas fases iniciais possuem custo de correção
altíssimo. Uma
coisa é o momento em que o erro ocorre (quanto mais cedo, mais caro); outra coisa é
o momento
em que um erro é identificado (quanto mais tarde, mais caro). Percebam que erros nas
fases iniciais
possuem custos de correção mais altos. Logo, o maior custo está na fase de
codificação? Não, está
na fase de requisitos que é a fase inicial!

Gabarito: Errado

Item. 52. (CESPE / SERPRO - 2008) O modelo em cascata consiste de fases e atividades que
devem ser
realizadas em sequência, de forma que uma atividade é requisito da outra.

Comentários:

No Modelo em Cascata, uma fase só se inicia após o término e aprovação da fase
anterior, isto é,
há uma sequência de desenvolvimento do projeto. Por exemplo, a Fase 4 só é iniciada
após o
término e aprovação da Fase 3. A Fase 5 só é iniciada após o término e aprovação da Fase 4.

Gabarito: Correto

Item. 53. (CESPE / MPE-AM - 2008) O modelo de desenvolvimento sequencial linear
tem como
característica principal a produção de uma versão básica, mas funcional, do software
desde as
primeiras fases.

Comentários:


VANTAGENS

É simples de entender e fácil de aplicar, facilitando o
planejamento.

Fixa pontos específicos para a entrega de artefatos.
Funciona bem para equipes tecnicamente fracas.

DESVANTAGENS

Divisão inflexível do projeto em estágios distintos.
Dificuldade em incorporar mudanças de requisitos.

Clientes só visualizam resultados próximos ao final do
projeto.


É fácil de gerenciar, devido a sua rigidez.

Realiza documentação extensa por cada fase ou
estágio.

Possibilita boa aderência a outros modelos de
processo.

Funciona bem com projetos pequenos e com
requisitos bem conhecidos.

Atrasa a redução de riscos.

Apenas a fase final produz um artefato de software
entregável.

Cliente deve saber todos os requisitos no início do
projeto.

Modelo inicial (Royce) não permitia feedback entre as
fases do projeto.

Pressupõe que os requisitos ficarão estáveis ao longo
do tempo.

Não funciona bem com projetos complexos e 00,
apesar de compatível.

Pelo contrário, somente nas fases finais que se tem uma versão! Essa definição está
mais com cara
de modelo de desenvolvimento em prototipagem.

Gabarito: Errado

Item. 54. (CESPEITJ-DF - 2008) No modelo de desenvolvimento incremental, embora haja
defasagem
entre os períodos de desenvolvimento de cada incremento, os incrementos são desenvolvidos
em paralelo.

Comentários:

Questão perfeita! Os incrementos são codificados não exatamente em paralelo - há uma
pequena
defasagem.

Gabarito: Correto

55.(CESPE/TST-2008) O modelo RAD (Rapid Application Development) consiste em uma
forma
de prototipação para esclarecer dúvidas da especificação do software.

Comentários:

RAD é um processo de desenvolvimento de software iterativo e incremental que enfatiza
um ciclo
de desenvolvimento curto. Ele não é uma forma de prototipação, apesar de poder utilizá-la.

Gabarito: Errado

56.(CESPE ITRE-MA - 2008) O modelo RAD (Rapid Application Development) é uma adaptação
de alta velocidade do modelo sequencial linear, conseguido por meio da construção
embasada
em componentes.

Comentários:


O RAD (Rapid Application Development) realmente é uma adaptação de alta velocidade do
modelo
sequencial linear (cascata). Além disso, ele se utiliza realmente de componentes prontos
para o
desenvolvimento rápido. Porque ele é considerado uma adaptação do modelo em cascata?
Porque
ele funciona como vários modelos em cascata trabalhando iterativamente. E qual o nome
disso?
Isso se chama Modelo iterativo e incremental!

Gabarito: Correto

57.(CESPE/TRE-MA-2oo8) O uso de uma abordagem de construção embasada em componentes
faz que o desenvolvimento no modelo RAD (Rapid Application Development) seja considerado
mais rápido

Comentários:

Perfeito, ela se utiliza de uma construção baseada em componentes, fazendo
com que o
desenvolvimento seja mais rápido.

Gabarito: Correto

Item. 58. (CESPE / MPE-AM - 2008) O modelo de desenvolvimento incremental combina
características
do modelo de desenvolvimento sequencial linear com características do modelo RAD, embora
isso resulte em projetos que sistematicamente apresentam maior duração que
aqueles feitos
com os dois modelos de desenvolvimento originais.

Comentários:

Modelo Incremental não combina características do Modelo Sequencial Linear com
RAD. Aliás,
RAD é Incremental!

Gabarito: Errado

59.(CESPE / TSE - 2006 - Item D) O modelo em cascata organiza o desenvolvimento em
fases.
Esse modelo encoraja a definição dos requisitos antes do restante do
desenvolvimento do
sistema. Após a especificação e a análise dos requisitos, têm-se o projeto, a
implementação e o
teste.

Comentários:

I POR SOMMERVILLE I PORROYCE POR PRESSMAN (4^
ED] | POR PRESSMAN [6* ED] I


Análise e Definição de
Requisitos

Requisitos de Sistema Modelagem e Engenharia
do Sistema/lnformação

Comunicação


Projeto de Sistema e
Software

Implementação e Teste
de Unidade

Integração e Teste de
Sistema

Operação e Manutenção

Requisitos de
Software

Análise
Projeto
Codificação
Teste
Operação

Análise de Requisitos de
Software

Projeto

Geração de Código

Teste e
Manutenção

Planejamento
Modelagem
Construção
Implantação

Perfeito! De fato, segue essa ordem!

Gabarito: Correto

6o.(CESPE / MPE-AM - 2005) O modelo RAD (rapid application development) é específico
para
projetos de software que empregam linguagens de programação de terceira geração.

Comentários:

Não existe qualquer limitação quanto a isso! Em geral, ele mais utilizado
com linguagens de
programação de quarta geração, mas não se limita a elas. Lembrando que,
grosso modo, as
linguagens de ia Geração são as Linguagens de Máquina (Ex: Binário); 2a Geração são
Linguagens
de Montagem (Ex: Assembler); as Linguagens de 3a Geração são as Linguagens de Alto
Nível (Ex:
Java, C++, etc); e as Linguagens de 4a Geração são as Linguagens de Altíssimo Nível
com objetivos
específicos (Ex: SQL para Bancos de Dados, APEX para RAD, MatLab para cálculo numérico).

Gabarito: Letra E

Item. 61. (CESPE / IGEPREV - 2005) O modelo Rapid Application Development (RAD) é
apropriado para
projetos que envolvem grandes riscos técnicos.

Comentários:

Pelo contrário, é apropriado para projetos que envolvem pequenos riscos técnicos.

Gabarito: Errado

Item. 62. (CESPE / ANS - 2005) O modelo Rapid Application Development (RAD) é uma
adaptação do
modelo em espiral para atender a projetos de software fundamentados em componentes.

Comentários:


Na verdade, ele é uma adaptação de alta velocidade do modelo em cascata.

Gabarito: Errado

63.(CESPE / AL-ES - 2005 - Item B) O modelo de desenvolvimento em cascata descreve
ciclos
sequenciais, incrementais e iterativos, possuindo, entre outras, as fases de
requisitos e
implementação.

Comentários:

Não! Ele não descreve ciclos, muito menos ciclos iterativos. Na verdade, essa é a
definição de
Modelo Iterativo e Incremental.

Gabarito: Errado

64.(CESPE / STJ - 2004) O modelo de desenvolvimento seqüencial linear, também
chamado
modelo clássico ou modelo em cascata, caracteriza-se por não acomodar adequadamente as
incertezas que existem no início de um projeto de software, em especial as
geradas pela
dificuldade do cliente de explicitar todos os requerimentos que o programa deve contemplar.

Comentários:

Como uma fase só se inicia após o término da fase anterior, só é possível em geral verificar se
houve
erros nas últimas fases - como pode ser visto na imagem abaixo. Em outros modelos,
os riscos são
reduzidos desde as primeiras fases do processo de desenvolvimento. Logo, lembrem-se que
ele
acumula riscos e não lida bem com requisitos voláteis.

Gabarito: Correto

Item. 65. (CESPE / TJ-PA - 2004 - Item D) A abordagem sistemática estritamente
linear para o
desenvolvimento de software é denominada modelo em cascata ou modelo sequencial linear.

Comentários:

Citado inicialmente em 1970 por W. Royce, também designado Cascata ou Clássico ou
Sequencial
ou Linear ou Tradicional ou Waterfall ou Rígido ou Monolítico (todos esses nomes já
caíram em
prova!). Esse nome é devido ao encadeamento simples de uma fase com a outra. Os
estágios do
modelo demonstram as principais atividades de desenvolvimento.

Gabarito: Correto


Item. 66. (CESPE / ABIN - 2004) O modelo de desenvolvimento seqüencial
linear, também
denominado modelo em cascata, é incompatível com o emprego detécnica de análise
orientada
a objetos no desenvolvimento de um sistema de informação.

Comentários:


VANTAGENS

É simples de entender e fácil de aplicar, facilitando o
planejamento.

Fixa pontos específicos para a entrega de artefatos.
Funciona bem para equipes tecnicamente fracas.

É fácil de gerenciar, devido a sua rigidez.

Realiza documentação extensa por cada fase ou
estágio.

Possibilita boa aderência a outros modelos de
processo.

Funciona bem com projetos pequenos e com
requisitos bem conhecidos.

DESVANTAGENS

Divisão inflexível do projeto em estágios distintos.
Dificuldade em incorporar mudanças de requisitos.

Clientes só visualizam resultados próximos ao final do
projeto.

Atrasa a redução de riscos.

Apenas a fase final produz um artefato de software
entregável.

Cliente deve saber todos os requisitos no início do
projeto.

Modelo inicial (Royce) não permitia feedback entre as
fases do projeto.

Pressupõe que os requisitos ficarão estáveis ao longo
do tempo.

Não funciona bem com projetos complexos e 00,
apesar de compatível.

Ele é compatível, mas não é recomendado! Por que, não? Imagina um projeto super
complexo que
utiliza uma análise orientada a objetos (que é um modelo mais sofisticado
que a análise
estruturada). Lembre-se que, no Modelo em Cascata, você não pode errar, porque se você
errar, os
riscos de o projeto falhar são enormes! Por essa razão, ele não é
recomendável, apesar de
compatível!

Gabarito: Errado

67.(CESPE / TRE-AL - 2004) O modelo cascata ou ciclo de vida clássico
necessita de uma
abordagem sistemática, que envolve, em primeiro lugar, o projeto e, em seguida, a
análise, a
codificação, os testes e a manutenção.

Comentários:

POR SOMMERVILLE | POR ROYCE POR PRESSMAN (4^ ED] |
POR PRESSMAN (6^ ED] |


Análise e Definição de
Requisitos

Requisitos de Sistema Modelagem e Engenharia
do Sistema/lnformação

Comunicação


Projeto de Sistema e
Software

Requisitos de
Software

Análise de Requisitos de
Software

Planejamento


Implementação e Teste Análise
de Unidade

Projeto Modelagem


Integração e Teste de
Sistema

Projeto

Geração de Código Construção


Operação e Manutenção Codificação
Teste

Operação

Primeiro Projeto e depois Análise? Não, Análise

Teste e Implantação

Manutenção
antes do Projeto!

Gabarito: Errado

Item. 68. (CESPE / BASA - 2004) O modelo embasado em prototipagem é um modelo de
processo
incremental que enfatiza um ciclo de desenvolvimento extremamente curto. A primeira fase
do
processo é a modelagem de negócio e a última é a fase de teste e entrega.

Comentários:

Ciclo de desenvolvimento curto? Isso é RAD e, não, Prototipagem! O RAD é um modelo
iterativo e
incremental, que enfatiza o ciclo de desenvolvimento curto (60 a 90 dias). Esse
desenvolvimento
ocorre tão rápido, porque é utilizada o reúso de componentes a exaustão.
Como muitos
componentes já estão testados, pode-se reduzir o tempo total de desenvolvimento.

Gabarito: Errado


QUESTõES CoMENTADAS - FCC

í. (FCC / TRF - 3a REGIÃO - 2019) Considere a figura abaixo.

Atividades simultâneas


Descrição
do esboço

Especificação

I i

► Desenvolvimento

II

Validação

O modelo de processo de software representado é:

a) orientado a reuso.

b) desenvolvimento incremental.

c) em cascata.

d) processo empírico.

e) processo unificado.

Comentários:

A imagem representa o modelo de processo de software representado pelo
desenvolvimento
incremental (vimos a mesma imagem na aula).

Gabarito: Letra B

Item. 2. (FCC / TST - 2012) A Engenharia de Software:

a) é uma área da computação que visa abordar de modo sistemático as questões técnicas
e não
técnicas no projeto, implantação, operação e manutenção no desenvolvimento de um software.

b) consiste em uma disciplina da computação que aborda assuntos relacionados a técnicas
para
a otimização de algoritmos e elaboração de ambientes de desenvolvimento.

c) trata-se de um ramo da TI que discute os aspectos técnicos e empíricos nos
processos de
desenvolvimento de sistemas, tal como a definição de artefatos para a modelagem ágil.

d) envolve um conjunto de itens que abordam os aspectos de análise de mercado,
concepção e
projeto de software, sendo independente da engenharia de um sistema.


e) agrupa as melhores práticas para a concepção, projeto, operação e manutenção de artefatos
que suportam a execução de programas de computador, tais como as
técnicas de
armazenamento e as estruturas em memória principal.

Comentários:

De acordo com Pressman: "A Engenharia de Software ocorre como consequência de um
processo
chamado Engenharia de Sistemas. Em vez de se concentrar somente no software, a
engenharia de
sistemas focaliza diversos elementos, analisando, projetando, e os organizando em um
sistema que
pode ser um produto, um serviço ou uma tecnologia para transformação da informação ou
controle".
Logo, vamos aos julgamentos:

(a) Perfeito, observem as palavras-chave: modo sistemático; questões técnicas e
não técnicas;
projeto, implantação, operação e manutenção de desenvolvimento de software.

(b) Técnicas para otimização de algoritmos e elaboração de ambientes de desenvolvimento? Não, isso
não é Engenharia de Software.

(c) Pessoal, discordo do gabarito! Certa vez, um aluno me disse que talvez fosse
porque aspectos
empíricos são mais voltados para metodologias ágeis. Sim, é verdade! No entanto, a
engenharia de
software trata também de metodologias ágeis. Se alguém encontrar o erro, avise :-]

(d) A Análise de Mercado serve mais como uma técnica para Análise de Interfaces, mas
pode ser
vista como um dos aspectos que envolvem a Engenharia de Software. Pressman afirma que:
"A
Análise de Mercado pode ser inestimável na definição de segmentos de mercado e no entendimento de
como cada segmento poderia usar o software de modos sutilmente diferentes". De todo
modo, a
questão está errada porque a Engenharia de Software depende da Engenharia de Sistema
(como é
mostrado acima).

(e) Suportam a execução? Não, suportam o desenvolvimento de programas de computador.

Gabarito: Letra A

Item. 3. (FCC / TRT6 - 2012) Considere: é uma disciplina que se ocupa de todos os aspectos da produção
de software, desde os estágios iniciais de especificação do sistema até a manutenção desse sistema,
depois que ele entrou em operação. Seu principal objetivo é fornecer uma estrutura
metodológica
para a construção de software com alta qualidade. A definição refere-se:

a) ao ciclo de vida do software.

b) à programação orientada a objetos.

c) à análise de sistemas.

d) à engenharia de requisitos.


e) à engenharia de software.

Comentários:

Engenharia de Software é uma disciplina de engenharia que se ocupa de todos os
aspectos da
produção de software, desde os estágios iniciais de especificação do sistema até a
manutenção
desse sistema, após sua entrada em produção. A meta principal da Engenharia de
Software é
desenvolver sistemas de software com boa relação custo-benefício. Essa é a pura
definição de
Engenharia de Software!

Gabarito: Letra E

Item. 4. (FCC / MPE-AP - 2012) Um processo de software é um conjunto de atividades
relacionadas que
levam à produção de um produto de software. Existem muitos processos de software
diferentes,
mas todos devem incluir quatro atividades fundamentais: especificação,
projeto e
implementação, validação e:

a) teste
b) evolução.

c) prototipação.

d) entrega.

e) modelagem.

Comentários:

As atividades são Especificação de Software; Desenvolvimento de Software
(Projeto e
Implementação); Validação de Software; e Evolução de Software. Logo, trata-se da evolução!

Gabarito: Letra B

Item. 5. (FCC / TJ-RJ - 2012 - Item E) Dos diferentes modelos para o ciclo de vida de
desenvolvimento
de um software é correto afirmar que o modelo em cascata é o mais recente e complexo.

Comentários:

Citado inicialmente em 1970 por W. Royce, também designado Cascata ou Clássico ou
Sequencial
ou Linear ou Tradicional ou Waterfall ou Rígido ou Monolítico (todos esses nomes já
caíram em
prova!). Esse nome é devido ao encadeamento simples de uma fase com a outra. Os
estágios do
modelo demonstram as principais atividades de desenvolvimento. Mais recente? Não, muito
antigo!
Complexo? Não, possui um encadeamento simples de fases.

Gabarito: Errado


Item. 6. (FCC / INFRAERO -2011) Em relação à Engenharia de Software, é INCORRETO afirmar:

a) O design de software, ao descrever os diversos aspectos que estarão presentes no
sistema
quando construído, permite que se faça a avaliação prévia para garantir que ele
alcance os
objetivos propostos pelos interessados.

b) A representação de um design de software mais simples para representar apenas as
suas
características essenciais busca atender ao princípio da abstração.

c) Iniciar a entrevista para obtenção dos requisitos de software com perguntas mais
genéricas e
finalizar com perguntas mais específicas sobre o sistema é o que caracteriza
a técnica de
entrevista estruturada em funil.

d) No contexto de levantamento de requisitos, funcionalidade é um dos aspectos que
deve ser
levado em conta na abordagem dos requisitos funcionais.

e) A representação é a linguagem do design, cujo único propósito é descrever um
sistema de
software que seja possível construir.

Comentários:

Descrever um sistema de software que seja possível construir não é o único, mas um
dos objetivos
da representação. Ela auxilia a comunicação entre as partes interessadas e serve também
como
documentação.

Gabarito: Letra E

Item. 7. (FCC / TRE-AM - 2010) A Engenharia de Software:

a) não tem como método a abordagem estruturada para o desenvolvimento de software, pois
baseia-se exclusivamente nos modelos de software, notações, regras e
técnicas de
desenvolvimento.

b) se confunde com a Ciência da Computação quando ambas tratam do desenvolvimento de
teorias, fundamentações e práticas de desenvolvimento de software.

c) tendo como foco apenas o tratamento dos aspectos de construção de software,
subsidia a
Engenharia de Sistemas no tratamento dos sistemas baseados em computadores,
incluindo
hardware e software.

d) tem como foco principal estabelecer uma abordagem sistemática de
desenvolvimento,
através de ferramentas e técnicas apropriadas, dependendo do problema a ser
abordado,
considerando restrições e recursos disponíveis.


e) segue princípios, tais como, o da Abstração, que identifica os aspectos
importantes sem
ignorar os detalhes e o da Composição, que agrupa as atividades em um único processo
para
distribuição aos especialistas.

Comentários:

(a) Errado. Pelo contrário, ela se baseia em uma abordagem estruturada e sistemática!
A IEEE
define engenharia de software como a aplicação de uma abordagem sistemática,
disciplinada e
quantificável de desenvolvimento, operação e manutenção de software. Já
Friedrich Bauer
conceitua como a criação e a utilização de sólidos princípios de engenharia a fim de
obter software
de maneira econômica, que seja confiável e que trabalhe em máquinas reais.

(b) Errado. Na verdade, Engenharia de Software é uma disciplina da Ciência da
Computação. A
Engenharia de Software tem por objetivos a aplicação de teoria, modelos, formalismos,
técnicas e
ferramentas da ciência da computação e áreas afins para a desenvolvimento
sistemático de
software. Associado ao desenvolvimento, é preciso também aplicar processos,
métodos e
ferramentas sendo que a pedra fundamental que sustenta a engenharia de software é a qualidade.

(c) Apenas o tratamento dos aspectos de construção de software?Só construção? Não! (d)
Correto, é
exatamente isso! (e) Composição? Não, Decomposição! Divide-se o problema em partes para
que
cada uma possa ser resolvida de uma forma mais específica. Além disso, a
abstração ignora
detalhes!

Gabarito: Letra D

Item. 8. (FCC / DPE/SP-2010) A Engenharia de Software:

I. não visa o desenvolvimento de teorias e fundamentações, preocupando-se unicamente com
as práticas de desenvolvimento de software.

II. tem como foco o tratamento dos aspectos de desenvolvimento de software,
abstraindo-se
dos sistemas baseados em computadores, incluindo hardware e software.

III. tem como métodos as abordagens estruturadas para o desenvolvimento de software que
incluem os modelos de software, notações, regras e maneiras de desenvolvimento.

IV. segue princípios, tais como, o da Abstração, que identifica os aspectos
importantes sem
ignorar os detalhes e o da Composição, que agrupa as atividades em um único processo
para
distribuição aos especialistas.

É correto o que se afirma em:


a) III e IV, apenas.

b) 1,11, III e IV.

c) I e II, apenas.

d) I, II e III, apenas.

e) II, III e IV, apenas.

Comentários:

(I) Errado, Sommerville diz: "Computer science focuses on theory and
fundamentais; software
engineering is concerned with the practicalities of developing and delivering useful
software". No
entanto, ele não diz que a engenharia de software se preocupa unicamente com as
práticas de
desenvolvimento de software.

(II) Errado, Pressman diz: "System engineering is concerned with all aspects of
computer-based
systems development including hardware, software, and process engineering" - a questão
trata da
Engenharia de Sistemas.

(III) Correto, de fato ela tem como métodos as abordagens estruturadas para o
desenvolvimento de
software que incluem os modelos de software, notações, regras e maneiras de desenvolvimento.

(IV) Errado, o princípio da abstração ignora os detalhes; e o princípio da composição
não existe - o
que existe é o princípio da decomposição. E ele divide o problema em partes menores.

Em suma, nenhuma das opções nos atende! Vocês sabem qual opção a banca marcou como correta?

A Letra D!ü Eela voltou atrás com os recursos? Não!!! Pois é, galera! Acostumem-se com isso :(

Gabarito: Letra D

Item. 9. (FCC/ AFR/SP - 2009) A engenharia de software está inserida no contexto:

a) das engenharias de sistemas, de processo e de produto.

b) da engenharia de sistemas, apenas.

c) das engenharias de processo e de produto, apenas.

d) das engenharias de sistemas e de processo, apenas.

e) das engenharias de sistemas e de produto, apenas.

Comentários:

A engenharia de sistemas está preocupada com todos os aspectos do desenvolvimento de
sistemas
computacionais, incluindo engenharia de hardware, engenharia de software e engenharia de
processos. Percebam, então, que a Engenharia de Sistemas está em um contexto com
várias outras
engenharias.


Gabarito: Letra A

io.(FCC / SEFAZ-SP -2009 - Item B) O processo de engenharia de software denominado ciclo de
vida clássico refere-se ao modelo incremental.

Comentários:

Citado inicialmente em 1970 por W. Royce, também designado Cascata ou Clássico ou
Sequencial
ou Linear ou Tradicional ou Waterfall ou Rígido ou Monolítico (todos esses nomes já
caíram em
prova!). Esse nome é devido ao encadeamento simples de uma fase com a outra. Os
estágios do
modelo demonstram as principais atividades de desenvolvimento. Logo, modelo clássico se
refere
a modelo em cascata, sequencial, linear, tradicional, waterfall, rígido ou monolítico.

Gabarito: Errado


QUESTõES CoMENTADAS - FG V

í. (FGV / COMPESA- 2016) Observe a figura a seguir, que representa um modelo de processo
de software.

Este modelo, algumas vezes chamado ciclo de vida clássico, sugere uma abordagem
sequencial
e sistemática para o desenvolvimento de software nos casos em que os
requisitos de um
problema são bem compreendidos e quando o trabalho flui da comunicação ao emprego de
forma relativamente linear. O modelo apresentado é denominado:

a) incremental.

b) cascata.

c) evolucionário.

d) unificado
e) especializado.

Comentários:

Palavras-chave: ciclo de vida clássico; abordagem sequencial e sistemática; útil quando
requisitos
são bem compreendidos. Trata-se do famoso Modelo em Cascata (Waterfall).

Gabarito: Letra B

Item. 2. (FGV / PGE-RO - 2015) A figura abaixo ilustra um modelo de processo, que
prescreve um
conjunto de elementos de processo como atividades de arcabouço, ações de engenharia de
software, tarefas, produtos de trabalho, mecanismos de garantia de qualidade e de
controle de
modificações para cada projeto.


Esse modelo é conhecido como Modelo:

a) por funções.

b) em cascata.

c) incremental.

d) em pacotes.

e) por módulos

Comentários:

POR SOMMERVILLE PORROYCE POR PRESSMAN (4^ ED) |
POR PRESSMAN (6ê ED]


Análise e Definição de
Requisitos

Projeto de Sistema e
Software

Requisitos de Sistema Modelagem e Engenharia
do Sistema/lnformação

Requisitos de Software Análise de Requisitos de

Software

Comunicação

Planejamento


Implementação e Teste de
Unidade

Integração e Teste de
Sistema

Análise Projeto Modelagem

Projeto Geração de Código Construção


Operação e Manutenção Codificação Teste e
Manutenção

Implantação

Teste
Operação

Trata-se das fases descritas pelo Pressman para o Modelo em Cascata.

Gabarito: Letra B

Item. 3. (FGV / BADESC - 2010) De acordo com Pressman, a engenharia de software é baseada em
camadas, com foco na qualidade. Essas camadas são:

a) métodos, processo e teste.

b) ferramentas, métodos e processo.

c) métodos, construção, teste e implantação.

d) planejamento, modelagem, construção, validação e implantação.


e) comunicação, planejamento, modelagem, construção e implantação.

Comentários:

Bastava lembrar da imagem para responder à questão!

Gabarito: Letra B

Item. 4. (FGV / Fiocruz - 2010) Rapid Application Development (RAD) é um modelo de
processo de
software incremental que enfatiza um ciclo de desenvolvimento curto, com o
uso de uma
abordagem de construção baseada em componentes. Nesse modelo, três das principais fases
são abrangidas pelas modelagens:

a) do negócio, dos recursos financeiros e das funções gerenciais.

b) do gerenciamento, dos recursos de TI e dos processos.

c) do planejamento, dos dados e das funções gerenciais.

d) do planejamento, dos recursos de TI e dos projetos
e) do negócio, dos dados e dos processos.

Comentários:


Equipe #3

Nesse modelo, três das principais fases são abrangidas pelas modelagens:
Modelagem de
Negócios, Modelagem de Dados e Modelagem de Processos.

Gabarito: Letra E

Item. 5. (FGV/CODESP-SP-2010) AUMLé uma linguagem visual para modelarsistemas orientados
a
objetos, sendo independente tanto de linguagens de programação quanto de
processos de
desenvolvimento. Nesse contexto, analise a figura abaixo, que representa um modelo de
ciclo
de vida para desenvolvimento de sistemas. Essa abordagem divide o
desenvolvimento de
software em ciclos, em que, em cada ciclo, podem ser identificadas as fases de
análise, projeto,
implementação e testes. Cada um dos ciclos considera um subconjunto de requisitos, e
estes
são desenvolvidos uma vez que sejam alocados a um ciclo de desenvolvimento. Esse
modelo de
ciclo de vida é denominado:

a) clássico;

b) em cascata;

c) prototipação;

d) estruturado por fases;

e) incremental e iterativo.

Comentários:

Uma informação bizarra: a questão menciona uma figura, mas a prova não trouxe figura
alguma e
a questão não foi anulada. De toda forma, a abordagem em ciclos em que, em cada
ciclo, podem
ser identificadas as fases de análise, projeto, implementação e testes, sendo que cada um dos
ciclos
considera um subconjunto de requisitos, e estes são desenvolvidos uma vez que sejam
alocados a
um ciclo de desenvolvimento é o modelo iterativo e incremental.

Gabarito: Letra E

Item. 6. (FGV / Senado Federal - 2008) Considere as seguintes assertivas sobre modelos de
processos
de software:

I. No modelo em cascata, a fase seguinte não deve iniciar antes que a fase precedente tenha sido
concluída.

II. No modelo evolucionário, a mudança constante tende a corrompera estrutura do software

III. A explícita consideração dos riscos no modelo em espiral distingue esse modelo dos
modelos
em cascata e evolucionário.

As assertivas corretas são:

a) somente I.

b) somente I e II.

c) somente I e III.

d) somente II e III.

e) I, lie III.

Comentários:

(I) Correto, uma fase só se inicia após o término e aprovação da fase anterior; (II)
Correto, muitas
mudanças tendem a corromper a estrutura do software e isso as tornam
difíceis e caras; (III)
Correto, a ideia do modelo espiral é representar um processo de software orientado a
riscos, o que
o diferencia dos demais modelos.

Gabarito: Letra E


QUESTõES CoMENTADAS - DIVERSAS

í. (VUNESP/TJM-SP-2021) O modelo de desenvolvimento de software RAD (Rapid
Application
Development) conta com uma fase de Modelagem, que compreende a modelagem de:

a) Negócio, Dados e Processo.

b) Teste, Integração e Negócio.

c) Protótipo, Entrega e Dados.

d) Comunicação, Integração e Teste.

e) Entrega, Comunicação e Protótipo.

Comentários:

RAD conta com uma fase de modelagem que compreende modelagem de negócio, modelagem de
dados e modelagem de processo.

Gabarito: Letra A

Item. 2. (VUNESP / PRODEST-ES - 2014) No modelo de ciclo de vida de software conhecido
como RAD
(Rapid Application Development) há duas atividades, cujas tarefas podem ser distribuídas
por
diversas equipes. Essas atividades são:

a) comunicação e modelagem
b) comunicação e planejamento.

c) integração e construção.

d) modelagem e construção.

e) planejamento e integração.

Comentários:

Modelagem de Negócio, Dados e Processos são frequentemente condensados na etapa
de
Modelagem e Geração da Aplicação, Teste e Modificação são frequentemente
condensados na
etapa de Construção. Logo, trata-se de Modelagem e Construção.

Gabarito: Letra D

Item. 3. (VUNESP / SPTrans - 2012) Uma das abordagens do processo de
desenvolvimento da
engenharia de software prevê a divisão em etapas, em que o fim de uma é a entrada
para a
próxima. Esse processo é conhecido como modelo:

a) Transformação.

b) Incremental.


c) Evolutivo.

d) Espiral.

e) Cascata.

Comentários:

No Modelo em Cascata, uma fase só se inicia após o término e aprovação da fase
anterior, isto é,
há uma sequência de desenvolvimento do projeto. Por exemplo, a Fase 4 só é iniciada
após o
término e aprovação da Fase 3. A Fase 5 só é iniciada após o término e aprovação da Fase
Item. 4. Logo,
conforme vimos em aula, trata-se do Modelo em Cascata.

Gabarito: Letra E

Item. 4. (CESGRANRIO / UNIRIO - 2019) O modelo de processo incremental é iterativo por
natureza e
produz a cada incremento uma versão operacional do produto, diferente de outros
modelos,
como, por exemplo, a prototipagem. Esse modelo incremental:

a) gera incrementos logo nas primeiras etapas, mas estes não podem ser entregues ao cliente.

b) possui unicamente atividades de codificação e teste nos seus incrementos.

c) deve ter, no máximo, 1 a 5 sprints quando planejados e gerenciados com métodos ágeis.

d) possui atividades de teste fora do incremento, realizadas por outra equipe que vai
integrando
incrementalmente o produto a cada etapa do teste.

e) combina elementos do modelo cascata, aplicado de maneira iterativa, sendo também
essa
filosofia incremental usada em processos ágeis.

Comentários:

(a) Errado, eles podem ser entregues aos clientes; (b) Errado, há outras
atividades como
planejamento, requisitos, etc; (c) Errado, não existe limite de sprints-que é um
conceito de uma
metodologia ágil chamada Scrum; (d) Errado, testes são realizados dentro das
etapas do
incremento; (e) Correto.

Gabarito: Letra E

Item. 5. (CESGRANRIO / Transpetro - 2018) O modelo em cascata ou linear é um modelo de
processo
de software que, a princípio, só deve ser usado se o(s):

a) feedback do usuário é necessário ao longo do desenvolvimento.

b) requisitos devem mudar ao longo do projeto.

c) requisitos são bem conhecidos.

d) riscos de negócio não são conhecidos.

e) usuários não sabem bem o que desejam.


Comentários:

(a) Errado, não se deve utilizar o modelo em cascata nesse caso, visto que o
feedback só é
necessário nas fases finais; (b) Errado, não se deve utilizar o modelo em cascata
nesse caso, visto
que requisitos não devem mudar ao longo do projeto; (c) Correto, o modelo
em cascata é
recomendado quando requisitos são bem conhecidos; (d) Errado, para utilizar o
modelo em
cascata, os riscos devem ser bem conhecidos; (e) Errado, para utilizar o
modelo em cascata,
usuários não sabem bem o que desejam.

Gabarito: Letra C

Item. 6. (CESGRANRIO/Transpetro-2018) Que tipo de processo de desenvolvimento de
software visa
a, inicialmente, prover todas as funcionalidades do sistema com uma fidelidade baixa e,
por
meio de ciclos, ir aumentando cada vez mais a fidelidade até que todas as
funcionalidades
estejam suportadas com a fidelidade máxima?

a) Preditivo
b) Linear
c) Iterativo
d) Incremental
e) Ágil

Comentários:

A questão trata do modelo em prototipagem, que é um tipo de modelo
evolucionário, que é
necessariamente um modelo iterativo.

Gabarito: Letra C

Item. 7. (CESGRANRIO /Transpetro - 2012) Na engenharia de software, existem diversos modelos
de
desenvolvimento de software, e, dentre eles, o modelo em cascata, o qual, no
contexto do
desenvolvimento de sistemas de software complexos, recomenda:

a) distribuir a elicitação dos requisitos desde o início até o fim do desenvolvimento.

b) dividir o desenvolvimento do produto de software em fases lineares e sequenciais.

c) enfatizar a avaliação e mitigação de riscos durante o desenvolvimento.

d) realizar entregas incrementais do produto de software ao longo do desenvolvimento.

e) usar prototipagem rápida para estimular o envolvimento do usuário no desenvolvimento.

Comentários:

Recomenda dividir o desenvolvimento do produto de software em fases lineares
e sequenciais.

Vocês se lembram que 0 Modelo em Cascata é um modelo sequencial linear? Pois é!


Gabarito: Letra B

Item. 8. (CESGRANRIO / EPE - 2012) Uma das críticas feitas ao modelo do ciclo
de vida do
desenvolvimento de software em cascata refere-se a:

a) exigência de conhecimento de avaliação e gerenciamento de risco para
evitar grandes
surpresas no projeto.

b) comprometimentos na qualidade e nas possibilidades de manutenção a longo
prazo,
parecendo um protótipo.

c) pouca flexibilidade para mudanças futuras, exigindo compromissos nas fases
iniciais do
projeto.

d) pouca visibilidade das etapas do processo, tornando cara a documentação de todas as
versões
dos sistemas.

e) exigências de velocidade as quais levam o engenheiro de software a utilizar
linguagens,
algoritmos ou ferramentas ineficientes ao longo de todo o projeto.

Comentários:

É conhecida a pouca flexibilidade do Modelo em Cascata em se adaptar a mudanças
conforme o
projeto progride. Mudanças nas fases iniciais do projeto têm menor impacto do que as
que são
necessárias nas fases finais do projeto. Por isso, o Modelo em Cascata é usado
preferencialmente
em projetos com requisitos muito bem definidos e com pouca volatilidade.

Gabarito: Letra C

Item. 9. (CESGRANRIO / PETROBRÁS - 2011) A especificação de uma
Metodologia de
Desenvolvimento de Sistemas tem como pré-requisito indispensável, em relação ao que será
adotado no processo de desenvolvimento, a definição do:

a) Engenheiro Responsável pelo Projeto
b) Documento de Controle de Sistemas
c) Software para Desenvolvimento
d) Ciclo de Vida do Software
e) Bloco de Atividades

Comentários:


A escolha de um modelo de ciclo de vida (para concursos, sinônimo de modelo de
processo) é o
ponto de partida para a definição de um processo de desenvolvimento de software. Um
modelo de
ciclo de vida, geralmente, organiza as macro-atividades básicas do processo,
estabelecendo
precedência e dependência entre as mesmas. Bem, essa questão foi bem escrita
(finalmente)!
Percebam que ele diferencia metodologia de desenvolvimento de software do ciclo
de vida de
software. Por exemplo: primeiro, eu defino que eu vou utilizar um ciclo de vida
evolutivo e depois
eu decido que eu vou utilizar a metodologia de desenvolvimento em espiral.

Gabarito: Letra D

io.(CESGRANRIO / PETROBRÁS -2010) No Ciclo de Vida Clássico, também chamado de Modelo
Sequencial Linear ou Modelo Cascata, é apresentada uma abordagem sistemática
composta
pelas seguintes atividades:

a) Análise de Requisitos de Software, Projeto, Geração de Código, Teste e Manutenção.

b) Modelagem e Engenharia do Sistema/lnformação, Análise de Requisitos de
Software,
Projeto, Geração de Código, Teste e Manutenção.

c) Modelagem e Engenharia do Sistema/lnformação, Projeto, Geração de Código,
Teste e
Manutenção.

d) Levantamento de Requisitos de Software, Projeto, Geração de Código e
Manutenção e
Análise de Requisitos de Software.

e) Levantamento de Requisitos de Software, Projeto, Geração de Código, Teste
Progressivo e
Manutenção.

Comentários:

POR SOMMERVILLE PORROYCE POR PRESSMAN (4* ED) |
POR PRESSMAN (6* ED]


Análise e Definição de
Requisitos

Requisitos de Sistema Modelagem e Engenharia
do Sistema/lnformação

Comunicação


Projeto de Sistema e
Software

Requisitos de
Software

Análise de Requisitos de
Software

Planejamento


Implementação e Teste
de Unidade

Integração e Teste de
Sistema

Análise Projeto Modelagem

Projeto Geração de Código Construção


Operação e Manutenção Codificação Teste e
Manutenção

Implantação

Teste
Operação


A Letra B está correta de acordo com o Pressman 4a Edição, mas está errada de
acordo com o
Pressman 6a Edição. Ademais, na questão ele sequer disse que era de acordo com o
Pressman.
Portanto, percebam que é um assunto polêmico e que as bancas deveriam
ignorar, mas
eventualmente elas cobram mesmo assim.

Gabarito: Letra B

n.(IBFC/ EBSERH - 2020) O ciclo de vida do software é a estrutura que
contém processos,
atividades e tarefas envolvidas no desenvolvimento, operação e manutenção de um produto
de
software. Assinale a alternativa que identifica corretamente o modelo mais antigo de
ciclo de
vida de software:

a) Espiral
b) Evolutivo
c) Incremental
d) Prototipagem
e) Cascata

Comentários:

O modelo mais antigo de ciclo de vida de software - também conhecido como modelo
clássico-é
o modelo em cascata.

Gabarito: Letra E

Item. 12. (INSTITUTO AOCP / Prefeitura de Novo Hamburgo - RS - 2020) Existem diversos
modelos de
desenvolvimento de software na literatura. Sabendo disso é correto afirmar que o modelo
que
se baseia na ideia de desenvolver uma versão inicial do produto, apresentá-la
para os
comentários dos clientes e continuar o desenvolvimento, por meio da criação
de diversas
versões, até que um produto final adequado seja alcançado, é o:

a) modelo orientado a objetos.

b) modelo orientado ao reúso.

c) modelo incremental.

d) modelo cascata.

e) modelo híbrido.

Comentários:

A ideia de desenvolver uma versão inicial do produto, apresentá-la para os comentários
dos clientes
e continuar o desenvolvimento, por meio da criação de diversas versões, até que um
produto final
adequado seja alcançado, é a definição clássica do Modelo Incremental.


Gabarito: Letra C

13.(INSTITUTO AOCP / UFPB- 2019) Existem diferentes processos de software,
porém todos
devem ser compostos por quatro etapas fundamentais. Assinale a alternativa que
apresenta
essas etapas.

a) 1. Análise de Software; 2. Desenvolvimento de Software; 3. Validação de
Software; 4.
Evolução de Software.

b) 1. Especificação de Software; 2. Projeto e Implementação de Software; 3.
Validação de
Software; 4. Evolução de Software.

c) 1. Análise de Requisitos; 2. Projeto e Implementação de Software; 3. Teste de
Software; 4.
Evolução de Software.

d) 1. Análise de Requisitos; 2. Projeto e Implementação de Software; 3. Validação de Software;

Item. 4. Suporte Técnico.

e) 1. Especificação de Software; 2. Desenvolvimento de Software; 3. Teste de
Software; 4.
Implantação de Software.

Comentários:

Existem dezenas de classificações de fases de processos de software. Eu não gosto
desse tipo de
questão porque é quase impossível saber à qual dessas classificações a questão se
refere. No caso
dessa questão, ela considerou que as quatro etapas fundamentais são: Especificação de
Software,
Projeto e Implementação de Software, Validação de Software e Evolução de Software.
Essas etapas
são parecidas com as fases do ciclo de vida do lan Sommerville: Especificação,
Desenvolvimento,
Validação e Evolução. É igual, professor? Não, mas é o que mais se aproxima!

Reitero: eu detesto questões desse tipo porque cabe praticamente qualquer resposta.

Gabarito: Letra B

i4-(IESES / SCGás - 2019) Assinale a associação correta presente na tabela

ASSOCIAÇÕES que define corretamente os elementos a definir da TABELA A com
as
definições ou caracterizações da TABELA B.


TAI BELA A

A definir

TAf3ELAB

Definição ou caracterização


1 Os processos de
software são

2 Modelos de
processos de
software

3 Modelos gerais de
processo

4 Engenharia de
requisitos

5 Validação de
software

A Modelos de processos de software

B as atividades envolvidas na produção de um
sistema de software
ó o processo de desenvolvimento de uma

C especificação de software

D descrevem a organização dos processos de
software

E é o processo de verificação de que o sistema
está de acordo com sua especificação e
satisfaz às necessidades reais dos usuános
do sistema.


TABELA A


a) 5

TABELA A


b)

TABELA A


c)

TABELA A


d)

TABELA B
B

A

C
D
E

TABELA B
B

A

D
C
E

TABELA B
C

A

B
E
D

TABELA B
C

B

E
D
A

Comentários:

(i) Os processos de software são (B) as atividades envolvidas na produção de um
sistema de
software; (2) Modelos de Processos de Software são (A) modelos de processos de
software; (3)
Modelos gerais de processo (D) descrevem a organização dos processos de
software; (4)
Engenharia de Requisitos (C) é o processo de desenvolvimento de uma especificação de
software;

(5) Validação de software (E) é o processo de verificação de que o sistema está de
acordo com sua
especificação e satisfaz às necessidades reais dos usuários do sistema.

Gabarito: Letra B

i5.(lnaz do Pará / CORE-SP - 2019) "O Modelo em Cascata (do inglês: Waterfall Model)
é um
modelo de desenvolvimento de software sequencial no qual o processo é visto como um
fluir
constante para frente (como uma cascata)"

Disponível em: https://pt.wikipedia.org/wiki/Modelo_em_cascata. Acesso em: 13.12.2018


No que tange ao processo de desenvolvimento de software em cascata, qual a
afirmativa
correta?

a) O modelo em cascata ou clássico também pode ser conhecido como "Bottom-UP".

b) Este modelo está defasado e não é mais utilizado, tendo sido descontinuado desde a
década
de 90.

c) As fases do modelo em cascata seguem a seguinte ordem: (1) Requerimento, (2)
Verificação,

(3) Projeto, (4) Implementação e (5) Manutenção.

d) As fases do modelo são como uma cascata, mantendo o fluxo do trabalho de cima
para baixo,
não podendo voltar às fases iniciais, somente pular etapas para frente.

e) A saída produzida em cada fase será utilizada como entrada da fase seguinte,
tornando o
modelo em cascata um modelo simples de entender e controlar.

Comentários:

(a) Errado, ele é conhecido como um modelo top-down - assim como uma cascata; (b)
Errado, ele
está defasado, mas continua sendo utilizado em diversos locais; (c) Errado, as fases
dependem do
autor, mas nenhum apresenta as fases da questão; (d) Errado, não é permitido pular
etapas para
frente; (e) Correto, a saída de uma fase é realmente utilizada como entrada para a
fase seguinte,
tornando-o um modelo simples de entender e controlar.

Gabarito: Letra E

i6.(IESES / SCGás - 2019) Assinale a alternativa que completa as lacunas
corretamente.
Considerando que o encadeamento entre uma fase e outra é uma das características do
modelo
em cascata, ou ciclo de vida de software. Este modelo é
um exemplo de.

Neste tipo de processo vocêe programar todas as atividades do processo antes de
a) um estágio-escrever-encerrar o projeto.

b) um processo dirigido a planos - deve planejar - começar a trabalhar nelas.

c) um estágio - deve planejar- encerrar o projeto.

d) um processo dirigido a planos-escrever-encerrar o projeto

Comentários:

Considerando que o encadeamento entre uma fase e outra é uma das características do
modelo em
cascata, ou ciclo de vida de software. Este modelo é um exemplo de um processo
dirigido a planos.
Neste tipo de processo você deve planejar e programar todas as atividades do processo
antes de
começara trabalhar nelas.

Gabarito: Letra B


Item. 17. (INSTITUTO AOCP / UFPB-2019) Há casos em que os requisitos de um problema são bem
compreendidos, por exemplo, quando o trabalho flui da comunicação ao emprego
de forma
relativamente linear. Sobre o modelo cascata, empregado na engenharia de software,
assinale
a alternativa correta.

a) O modelo cascata, algumas vezes denominado ciclo de vida clássico, sugere uma
abordagem
sequencial e sistemática para o desenvolvimento do software, começando com o levantamento
de necessidades por parte do cliente, avançando pelas fases de planejamento,
modelagem,
construção, emprego e culminando no suporte contínuo do software concluído.

b) O modelo cascata é projetado para o desenvolvimento do software de forma incremental.

c) O modelo cascata nada mais é que a criação de protótipos.

d) No modelo cascata, o software é desenvolvido em uma série de versões
evolucionárias. Nas
primeiras iterações, a versão pode consistir em um modelo ou em um protótipo.

e) O modelo cascata combina fluxos de processo linear e paralelo dos elementos. Esse
modelo
aplica as sequências lineares de forma escalonada. Cada sequência linear produz
incrementos
entregáveis do software.

Comentários:

(a) Correto; (b) Errado, esse seria o modelo iterativo e incremental; (c) Errado, esse
seria o modelo
em prototipação; (d) Errado, esse seria o modelo evolucionário; (e) Errado, não há fluxos
paralelos.

Gabarito: Letra A

18.(AOCP / EMPREL - 2019) O ciclo de vida clássico, que foi o primeiro modelo
publicado de
desenvolvimento de software, é conhecido como:

a) Cascata.

b) Espiral.

c) Incremental.

d) Evolucionário.

e) Prototipação.

Comentários:

O ciclo de vida clássico é conhecido como modelo em cascata.

Gabarito: Letra A


ig.(IBFC / Emdec - 2019) Sobre alguns modelos do ciclo de vida de desenvolvimento de
software,
assinale a alternativa correta.

a) Incremental
b) Curva
c) Estrela
d) Circular

Comentários:

Circular, Estrela e Curva não são modelos de ciclo de desenvolvimento de software -
incremental,
sim.

Gabarito: Letra A

2o.(SELECON / Prefeitura de Boa Vista - RR-2019) No que tange à Engenharia de
Software, um
dos ciclos de vida para o desenvolvimento de sistemas preconiza que os requisitos do
cliente são
obtidos e, de acordo com a funcionalidade, são agrupados em módulos.
Após este
agrupamento, a equipe, junto ao cliente, define a prioridade em que cada
módulo será
desenvolvido, escolha baseada na importância daquela funcionalidade ao negócio do
cliente.
Cada módulo passa portodas as fases de projeto, conforme se observa na figura a
seguir, e será
entregue ao cliente um software operacional. Assim, o cliente receberá parte do produto
final
em menos tempo.

Esse ciclo de vida é conhecido como:

a) cascata
b) espiral
c) incremental
d) evolutivo


Comentários:

Esse ciclo que se repete iterativamente incrementando funcionalidades é conhecido como
iterativo
e incremental (ou simplesmente incremental).

Gabarito: Letra C

2i.(FAURGS/ BANRISUL - 2018) se preocupa com todos os
aspectos do
desenvolvimento de sistemas computacionais, incluindo engenharia de hardware,
software e
processo; eé uma disciplina da engenharia que se preocupa com todos
aspectos da
produção de software, desde os estágios iniciais da especificação do sistema
até sua
manutenção, quando o sistema já está sendo usado.

Assinale a alternativa que completa, correta e respectivamente, as lacunas do texto acima.

a) Engenharia de Domínio - Engenharia de Software
b) Engenharia Reversa - Engenharia de Sistemas
c) Engenharia de Sistemas - Engenharia de Domínio
d) Engenharia de Sistemas - Engenharia de Software
e) Engenharia Reversa - Engenharia de Domínio

Comentários:

Engenharia de Sistemas se preocupa com todos os aspectos do desenvolvimento
de sistemas
computacionais, incluindo engenharia de hardware, software e processo; e
Engenharia de
Softaware é uma disciplina da engenharia que se preocupa com todos aspectos
da produção
de software, desde os estágios iniciais da especificação do sistema até sua manutenção,
quando o
sistema já está sendo usado.

Gabarito: Letra D

22.(FAURGS/ BANRISUL - 2018) Considere as seguintes afirmações sobre
Princípios de
Engenharia de Software.

I - São utilizadas diferentes técnicas de engenharia de software para cada tipo de
sistema,
porque cada software tem características bastante diversas.

II - Uma característica fundamental de um sistema de software é a
eficiência, pois
o software não deve desperdiçar os recursos do sistema, como memória e ciclos do
processador.
Eficiência inclui capacidade de resposta, tempo de processamento, uso da memória, etc.


III - Engenheiros de software não devem preocupar-se apenas com questões técnicas,
devendo
se comportar de forma ética e moralmente responsável, pois têm
responsabilidades com a
profissão de engenharia e com a sociedade.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

Comentários:

(I) Correto, cada software tem características particulares; (II) Correto, eficiência
está diretamente
ligada a recursos gastos em relação à precisão e integridade com que os usuários
atingem as suas
metas; (III) Correto, engenharia de software envolve tanto aspectos técnicos
quanto aspectos
éticos, morais, econômicos, etc.

Gabarito: Letra E

23.(FAURGS / TJ-RS - 2018) Considere as seguintes afirmações sobre o modelo
cascata de
desenvolvimento de software.

I - É um exemplo de processo dirigido a planos; em princípio, deve-se
planejar todas as
atividades do processo antes de se começar a trabalhar nelas.

II - É consistente com outros modelos de processos de engenharia e a
documentação é
produzida em cada fase do ciclo. Dessa forma, o processo torna-se visível e os
gerentes podem
monitorar o progresso de acordo com o plano de desenvolvimento.

III- Sua maior vantagem é a divisão inflexível do projeto em estágios distintos, de
forma que os
compromissos devem ser assumidos em um estágio inicial do processo, o que
facilita que
atendam às mudanças de requisitos dos clientes.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.


Comentários:

(I) Correto, trata-se realmente de uma metodologia dirigida a planos; (II) Correto, o
modelo em
cascata é - sim - consistente com outros modelos de processos de engenharia
e temos uma
documentação ao fim de cada fase. Isso torna o processo visível e o monitoramento do
progresso
mais simples; (III) Errado, essa é sua maior desvantagem, visto que dificulta
que atendam às
mudanças de requisitos dos clientes.

Gabarito: Letra B

24.(FAURGS / BANRISUL-2018) Há vários modelos de processo de software, sendo que cada
um
define um fluxo de processo que invoca cada atividade do desenvolvimento de forma
diversa. O
modelo , algumas vezes chamado ciclo de vida clássico, é um
exemplo de
processo dirigido a planos, pois deve-se planejar todas as atividades (estágios) do
processo
antes de começar a trabalhar nelas. Em princípio, o estágio seguinte não deve ser
iniciado até
que o estágio anterior seja concluído, mas na prática este processo não é um modelo
linear
simples, envolvendo o feedback de um estágio a outro. Assim os documentos e
artefatos
produzidos em cada estágio podem ser modificados para refletirem as alterações em cada
um
deles. Este modelo é consistente com outros modelos de processo de
engenharia, e a
documentação é produzida em cada estágio do ciclo. Desta forma, o processo torna-se
visível e
os gerentes podem monitorar o progresso de acordo com o plano de desenvolvimento. Seu
maior problema é a divisão inflexível do projeto em estágios distintos e, por isso,
deve ser usado
apenas quando os requisitos são bem compreendidos e pouco provavelmente venham a ser
radicalmente alterados durante o desenvolvimento.

Assinale a alternativa que preenche corretamente a lacuna do texto acima:

a) cascata (waterfall)

b) espiral
c) orientado a desenvolvimento incremental
d) baseado em componentes
e) prototipação

Comentários:

Modelo de ciclo de vida clássico? Modelo em Cascata (Waterfall).

Gabarito: Letra A

Item. 25. (COSEPE / UFPI -2018) O modelo cascata é um dos paradigmas mais antigos da
engenharia de
software. Dentre os problemas às vezes encontrados quando se aplica o modelo cascata,
tem-
se:


a) A etapa de comunicação ser responsável pelo levantamento das necessidades.

b) A existência de uma variação na representação do modelo, denominada de modelo V.

c) O modelo ser equivocadamente aplicado a problemas com requisitos bem
definidos e
razoavelmente estáveis.

d) O uso do fluxo sequencial proposto pelo modelo, visto que projetos reais raramente
seguem
tal fluxo.

e) A existência de somente cinco etapas no modelo, da comunicação ao emprego.

Comentários:

(a) Errado. Isso não é um problema do modelo em cascata; (b) Errado, Isso não é um
problema do
modelo em cascata; (c) Errado. Essa é uma característica do modelo e, não, um
problema; (d)
Correto. De acordo com Pressman, projetos reais raramente seguem o fluxo
sequencial que o
modelo propõe. Embora o modelo linear possa conter iterações, ele o faz
indiretamente. Como
consequência, mudanças podem provocar confusão à medida que a equipe de projeto
prossegue;

(e) Errado. Isso não é um problema do modelo em cascata.

Gabarito: Letra D

Item. 26. (Gestão Concursos / EMATER - 2018) O processo de um software é um conjunto de
atividades
que conduz ao desenvolvimento do produto software e o modelo de processo é uma
descrição
simplificada do processo. Qual é a característica que define o modelo cascata?

a) Atividades intercaladas.

b) Atividades sequenciais.

c) Rápida entrega do software.

d) Existência de componentes reusáveis.

Comentários:

(a) Errado, atividades são sequenciais; (b) Correto, atividades são sequenciais; (c)
Errado, não há
garantia de rápida entrega de software; (d) Errado, em geral não se utiliza componentes reusáveis.

Gabarito: Letra B

27.(FADESP / IF-PA - 2018) O modelo de desenvolvimento de software em
cascata, também
conhecido como ciclo de vida clássico, sugere uma abordagem sistemática e sequencial
para o
desenvolvimento de softwares que começa com a especificação dos requisitos e
termina na
manutenção do software acabado. Nos últimos anos, este modelo de ciclo de
desenvolvimento
vem sofrendo várias críticas quanto a sua eficácia. Assim, é correto afirmar que um
dos possíveis
problemas do ciclo de vida clássico é:

a) a exigência do modelo para que o cliente estabeleça todos os requisitos explicitamente.


b) a construção problemática dos componentes, caso o sistema não possa ser adequadamente
modularizado.

c) a responsabilidade do levantamento das necessidades pela etapa de comunicação.

d) a aplicação do modelo de forma incorreta a problemas com requisitos bem
definidos e
razoavelmente estáveis.

e) a existência de somente cinco etapas no modelo, da comunicação à imantação.

Comentários:

(a) Correto, um dos principais problemas é que o cliente deve estabelecer
todos os reqisitos
explicitamente no início do projeto; (b) Errado, isso não tem nenhuma relação com o
modelo em
cascata; (c) Errado, esse não é um problema do modelo em cascata - é apenas uma
característica;

(d) Errado, esse não é um problema específico do modelo em cascata; (e) Errado, esse
não é um
problema do modelo em cascata - é apenas uma característica.

Gabarito: Letra A

28.(QUADRIX / CRM-PR - 2018) É no estágio final do modelo em cascata, ou ciclo de
vida de
software, operação e manutenção, que o software é colocado em uso.

Comentários:

Pefeito! No modelo em cascata, o software só entra em uso no final do ciclo de vida.

Gabarito: Correto

2g.(QUADRIX / CRM-PR - 2018) O modelo em cascata é composto por três estágios, que
são
independentes entre si: análise e definição de requisitos; implementação e
teste unitário; e
operação e manutenção.

Comentários:

Segundo Sommerville, as etapas do modelo em cascata são: análise e definição de
requisitos;
projeto de sistema e software; implementação e teste de unidade; integração e teste de
sistema;
e operação e manutenção. Logo, faltam dois estágios!

Gabarito: Errado

Item. 30. (FAURGS / UFRGS - 2018) Considere as afirmações abaixo sobre Engenharia de Software:

I - A Engenharia de Software não se preocupa apenas com os processos
técnicos do
desenvolvimento de software. Ela também inclui atividades como gerenciamento de projeto de
software e desenvolvimento de ferramentas, métodos e teorias para apoiar a
produção de
software.

II - Por ser uma abordagem sistemática para a produção de software, a Engenharia de
Software
propõe técnicas e métodos universais que são adequados a todos os sistemas e a todas
as
empresas.

III - Um processo de software é uma sequência de atividades que leva à produção de
um produto
de software.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

Comentários:

(I) Correto, questão retirada litealmente do livro do Sommerville; (II) Errado,
um processo de
software não pode ser definido de forma universal. Para ser eficaz e conduzir à
construção de
produtos de boa qualidade, um processo deve ser adequado às especificidades
do projeto em
questão. Deste modo, processos devem ser definidos caso a caso, considerando-se
diversos
aspectos específicos do projeto em questão; (III) Correto, um processo de software é
realmente
uma sequência de atividades que leva à produção de um produto de software.

Gabarito: Letra C

Item. 31. (FAURGS / BANRISUL - 2018) Considere as seguintes afirmações sobre processos de software.

I - Um processo de software é um conjunto de atividades relacionadas que levam à
produção de
um produto de software.

II - Os processos ágeis são uma categoria de processo de software em que o
planejamento não
é gradativo e, por isso, torna-se mais difícil alterar o processo de
maneira que reflita as
necessidades de mudança dos clientes.

III - Em organizações nas quais a diversidade de processos de software é reduzida, os
processos
de software podem ser melhorados pela padronização. Isso possibilita uma
melhor
comunicação, além de redução no período de treinamento, e torna mais econômico o apoio
ao
processo automatizado.


Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

Comentários:

(I) Correto, definição perfeita de processo de software; (II) Errado, não vimos
metodologias ágeis,
mas é justamente o contrário: ocorre um planejamento gradativo tornando mais
fácil aterar o
processo de maneira que reflita as necessidades de mudança dos
clientes; (III) Correto,
organizações com menos diversidade de processos de software evidentemente podem
melhorá-
los com maior facilidade, possibilitando melhor padronização,
comunicação, treinamento e
economia.

Gabarito: Letra C

32.(IBADE/ IPM - JP - 2018) No que diz respeito à Engenharia de Software,
um modelo de
processo é visualizado como um ciclo de vida constituído da especificação, do
desenvolvimento,
da validação e da evolução, e as representa como fases do processo, cada uma separada
das
outras, tais como especificação de requisitos, projeto de software, implementação e
testes. Esse
modelo de processo é denominado Modelo:

a) baseado em Prototipação.

b) baseado em Eventos.

c) em Espiral.

d) em Árvore.

e) em Cascata.

Comentários:

Quando a questão afirma que cada fase é separada das outras, podemos inferir que elas
ocorrem
de forma sequencial. Logo, trata-se do Modelo em Cascata.

Gabarito: Letra E

33-(AOCP / UNIR - 2018) No modelo cascata, o resultado de cada fase envolve um ou
mais
documentos que são aprovados e assinados. A fase seguinte só é iniciada após a
conclusão da
fase precedente, mas, na prática, eles se sobrepõem e trocam informações. Durante o
projeto,
são identificados problemas com os requisitos; durante a codificação, são verificados problemas
do projeto, e assim por diante. O processo não é um modelo linear simples, mas
envolve uma
sequência de iterações das atividades de desenvolvimento.

Comentários:

Questão retirada literalmente do livro do lan Sommerville. De fato,
intercorrências de uma fase
podem auxiliar em outras fases na prática!

Gabarito: Correto

34.(FUNDATEC / CIGA-SC - 2018) Para responder à questão, considere a Figura 8, que
mostra,
esquematicamente, um modelo de processo ou paradigma da engenharia de software, utilizado
no desenvolvimento de sistemas computacionais.

A Figura 8 exibe, esquematicamente, o modelo de processo de desenvolvimento de software,
chamado de:

a) Espiral.

b) Cascata.

c) Prototipação.

d) Orientado a reuso.

e) Desenvolvimento incremental.

Comentários:

A figura exibe um modelo de processo de desenvolvimento de software chamado
Modelo em
Cascata.

Gabarito: Letra B


35-(COMPERVE / UFRN - 2018) Considere as afirmativas apresentadas abaixo a respeito dos
modelos de processos de software cascata (waterfall) e incremental.

I Uma das vantagens do modelo de processo cascata é que ele antecipa eventuais
correções a
serem feitas nos requisitos do software.

II O modelo de processos cascata é recomendado quando os requisitos são estáveis e claros.

III No desenvolvimento incremental, a arquitetura e o projeto do software tendem a
manter-se
estáveis.

IV No desenvolvimento incremental, o acompanhamento e o progresso das
atividades são
avaliados pela entrega de artefatos.

Estão corretas as afirmativas:

a) lie IV.

b) I e IV.

c) I e III.

d) lie III.

Comentários:

(I) Errado. Pelo contrário, ele atrasa a redução de riscos e eventuais correções; (II)
Correto. O
modelo em cascata é realmente recomendado quando os requisitos são estáveis e
claros; (III)
Errado. No desenvolvimento incremental, a arquitetura e o projeto tendem a se manter
instáveis;

(IV) Correto. O acompanhamento e o progresso das atividades são - de fato
- avaliados pela
entrega dos artefatos a cada iteração.

Gabarito: Letra A

36.OESES / CEGÁS - 2017) Assinale a alternativa que preenche as lacunas corretamente
relativa a
definição abaixo para Engenharia de Software.

De acordo com a IEEE Engenharia de Software é a aplicação de uma abordagem
sistemática,
e quantificável no desenvolvimento,e manutenção de softwares.

a) Incremental - documentação.

b) Estruturada - implantação.

c) Disciplinada - operação.

d) Completa - implementação.

Comentários:


A definição oficial da IEEE afirma que engenharia de software é a aplicação de uma
abordagem
sistemática, disciplinada e quantificável no desenvolvimento, operação e
manutenção de
softwares. A questão cobra simplesmente um decoreba de definição!

Gabarito: Letra C

37.(COPESE / UFPI - 2014) O modelo RAD (Rapid Application Development) é um
modelo
incremental que enfatiza um ciclo de desenvolvimento curto, sendo construído
baseado em
componentes.

Comentários:

Perfeito! Incremental?Sim! Ciclo de desenvolvimento curto? Sim! Baseado em componentes? Sim!

Gabarito: Correto

38.(MPE-RS / MPE-RS -2012) O ciclo de vida básico de um software compreende:

a) a implementação, a implantação e o teste.

b) a análise, a segurança e o controle de usuários.

c) a implementação, a análise e o teste.

d) a implementação, a validação e as vendas.

e) a análise, o projeto, a implementação e o teste.

Comentários:

Alguns autores afirmam que os modelos de ciclo de vida básicos, de maneira geral,
contemplam
pelo menos as fases de: Planejamento; Análise e Especificação de
Requisitos; Projeto;
Implementação; Testes; Entrega e Implantação; Operação; e Manutenção. Aqui
temos que
escolher a mais correta, na medida em que a primeira, terceira e última opções
estão corretas.
Nesse sentido, a última opção é a mais correta!

Gabarito: Letra E

39.(Instituto Cidade / TCM-GO - 2012) De acordo com a engenharia de
software, como todo
produto industrial, o software possui um ciclo de vida. Cada fase do ciclo de vida
possui divisões
e subdivisões. Em qual fase avaliamos a necessidade de evolução dos softwares
em
funcionamento para novas plataformas operacionais ou para a incorporação
de novos
requisitos?

a) Fase de operação;

b) Fase de retirada;


c) Fase de definição;

d) Fase de design.

e) Fase de desenvolvimento;

Comentários:

F 1 CICLO DE r 1


OPERAÇÃO

k À

VIDA DE
SOFTWARE

IPROJETO

k
r 1

TESTES

k À

A fase retirada é um grande desafio para os tempos atuais. Diversos softwares que
estão em
funcionamento em empresas possuem excelente níveis de confiabilidade e de
correção. No
entanto, eles precisam evoluir para novas plataformas operacionais ou para a
incorporação de
novos requisitos.

A retirada desses softwares legados em uma empresa é sempre uma decisão difícil: como
abrir mão
daquilo que é confiável e ao qual os funcionários estão acostumados, após anos de
treinamento e
utilização? Portanto, processos de reengenharia podem ser aplicados para viabilizar a
transição ou
migração de um software legado para um novo software de forma a proporcionar uma
retirada mais
suave.

A avaliação da necessidade de evolução do software em funcionamento para novas
plataformas
operacionais ou para a incorporação de novos requisitos realmente ocorrem na fase de retirada.

Gabarito: Letra B

4O.(UPANET/ JUCEPE-2012) O Desenvolvimento Rápido de Aplicações (RAD-Rapid
Application
Development) pode fazer uso do processo de desenvolvimento conjunto de aplicações (JAD -
Joint Application Development) para coletar dados e analisar requisitos.

Comentários:

Questão estranha! Pode usar o JAD? Claro, É uma técnica para levantar requisitos. Por
que não
poderia?


Gabarito: Correto

4i.(FUNIVERSA / IPHAN - 2009) A Engenharia de Software resume-se em um
conjunto de
técnicas utilizadas para o desenvolvimento e manutenção de sistemas
computadorizados,
visando produzir e manter softwares de forma padronizada e com qualidade. Ela obedece a
alguns princípios como (1) Formalidade, (2) Abstração, (3) Decomposição, (4)
Generalização e

(5) Flexibilização. Assinale a alternativa que apresenta conceito correto sobre os
princípios da
Engenharia de Software.

a) A flexibilização é o processo que permite que o software possa ser alterado, sem
causar
problemas para sua execução.

b) Aformalidade é a maneira usada para resolverum problema, deforma genérica, com o
intuito
de poder reaproveitar essa solução em outras situações semelhantes.

c) A generalização preocupa-se com a identificação de um determinado fenômeno da
realidade,
sem se preocupar com detalhes, considerando apenas os aspectos mais relevantes.

d) Pelo princípio da decomposição, o software deve ser desenvolvido de acordo com
passos
definidos com precisão e seguidos de maneira efetiva.

e) A abstração é a técnica de se dividir o problema em partes, de maneira que cada
uma possa
ser resolvida de uma forma mais específica.

Comentários:

A Engenharia de Software possui alguns princípios, tais como: Formalidade, em que o
software
deve ser desenvolvido de acordo com passos definidos com precisão e seguidos de
maneira efetiva;
Abstração, preocupa-se com a identificação de um determinado fenômeno da realidade, sem
se
preocupar com detalhes, considerando apenas os aspectos mais relevantes.

Há a Decomposição, em que se divide o problema em partes, de maneira que cada uma
possa ser
resolvida de uma forma mais específica; Generalização, maneira usada para resolver um
problema,
de forma genérica, com o intuito de reaproveitar essa solução em outras situações;
Flexibilização
é o processo que permite que o software possa ser alterado, sem causar problemas para
sua
execução. Logo, a flexibilização é o processo que permite que o software possa ser
alterado, sem
causar problemas para sua execução.

Gabarito: Letra A


LISTA DE QUESTõES - CESPE

í. (CESPE / BANRISUL - 2022) Um dos problemas da aplicação do modelo
cascata no
desenvolvimento de um projeto reside no fato de que uma versão operacional do programa
não
estará disponível antes que o projeto esteja perto do final, por conta do estado de
bloqueio que
a natureza linear do ciclo de vida clássico produz.

Item. 2. (CESPE / BANRISUL- 2022) O modelo cascata é frequentemente inadequado para os
casos de
desenvolvimento de soluções de software em que há ritmo acelerado e volume
intenso de
mudanças de características, todavia ele pode servir como um modelo de
processo útil em
situações nas quais os requisitos são fixos.

Item. 3. (CESPE / BANRISUL - 2022) O modelo do ciclo de vida clássico sugere uma
abordagem
sequencial para desenvolvimento de software, começando com a especificação dos requisitos
do cliente, avançando pelas fases de planejamento e modelagem, e culminando
no suporte
contínuo do software concluído.

Item. 4. (CESPE / FUNPRESP-EXE - 2022) No modelo em espiral de desenvolvimento de
software, cada
giro ou loop da espiral representa uma fase do processo de software.

Item. 5. (CESPE / TJ-RJ - 2021) Na engenharia de software, pode-se dividir uma metodologia
genérica
em cinco macroatividades; entre elas, a que tem como objetivo criar um esboço do
projeto a ser
desenvolvido é:

a) o planejamento.

b) a modelagem.

c) o emprego.

d) a comunicação.

e) a construção.

Item. 6. (CESPE / Polícia Federal - 2021) Uma das etapas descritas em um método
desenvolvimento de
sistema clássico é a análise e definição de requisitos, etapa em que as restrições e
as metas do
sistema são obtidas por meio de consulta a usuários, com o objetivo de realizar a
especificação
do sistema.

Item. 7. (CESPE / SERPRO - 2021) No modelo em cascata, dada a dificuldade natural para
estabelecer
todos os requisitos na fase inicial do projeto, os requisitos são definidos ao longo
de todas as
fases, acomodando-se gradualmente as incertezas e eventuais mudanças do projeto.

Item. 8. (CESPE/SERPRO-2021) No modelo iterativo, as iterações na fase de construção
concentram-
se nas atividades de requisitos, gerenciamento, design e testes.


Item. 9. (CESPE / Ministério da Economia - 2020) Engenharia de software (ES) é um processo,
expresso
como o conjunto de todas as atividades relacionadas ao desenvolvimento, ao
controle, à
validação e à manutenção de um software operacional, abrangendo atividades
técnicas e
gerenciais.

Item. 10. (CESPE / Ministério da Economia- 2020) Entre os modelos de processo
aplicados ao
desenvolvimento de software, o modelo cascata apresenta desvantagens por, entre
outros
motivos, não ter flexibilidade com requisitos, não produzir resultados tangíveis até a
fase de
codificação e dificultar o estabelecimento de requisitos completos antes de começar a codificar.

Item. 11. (CESPE / TCE-RO - 2019) O modelo de desenvolvimento de sistemas cascata:

a) é voltado para requisitos de sistemas de software e, por isso, não engloba os
requisitos
de hardware.

b) prevê que os estágios sejam iniciados toda vez que a fase anteriortenha concluído
a etapa de
documentação.

c) envolve o feedback de uma fase para outra, por ser um modelo linear simples.

d) é sequencial, o que impede que os documentos produzidos em cada fase sejam
modificados
para refletirem as alterações feitas em cada um deles.

e) é consistente com outros modelos de processos de engenharia, apesar de haver uma
divisão
inflexível do projeto em estágios distintos.

Item. 12. (CESPE / EBSERH - 2018) O modelo de ciclo de vida em cascata tem como
características o
estabelecimento, no início do projeto, de requisitos de maneira completa, correta e
clara, e a
possibilidade de disponibilização de várias versões operacionais do software antes da
conclusão
do projeto.

Item. 13. (CESPE / IPHAN - 2018) No modelo em cascata, com exceção do sequenciamento dos
estágios
de requisitos e de análise, os demais são executados em paralelo, iniciando-se antes
dotérmino
do estágio seguinte.

Item. 14. (CESPE ITCE-PR - 2016 - Item B) A engenharia de software refere-se ao estudo das
teorias e
fundamentos da computação, ficando o desenvolvimento de software a cargo da
ciência da
computação.

Item. 15. (CESPE / TCE/PR - 2016 - Item E) O conceito de software se restringe ao
desenvolvimento do
código em determinada linguagem e seu armazenamento em arquivos.

Item. 16. (CESPE / TCE-PR -2016) As fases do ciclo de vida de um software são:


a) concepção, desenvolvimento, entrega e encerramento.

b) iniciação, elaboração, construção e manutenção.

c) escopo, estimativas, projeto e processo e gerência de riscos.

d) análise, desenvolvimento, teste, empacotamento e entrega.

e) planejamento, análise e especificação de requisitos, projeto, implementação, testes,
entrega
e implantação, operação e manutenção.

Item. 17. (CESPE / TCE-PR - 2016 - Item A) A engenharia de software está relacionada aos
diversos
aspectos de produção de software e inclui as atividades de especificação,
desenvolvimento,
validação e evolução de software.

Item. 18. (CESPE / TCE-PR - 2016 - Item D) Um processo de software é composto por quatro
atividades
fundamentais: iniciação, desenvolvimento, entrega e encerramento.

Item. 19. (CESPE / TCE-PR - 2016) O modelo de desenvolvimento em cascata é utilizado em
caso de
divergência nos requisitos de um software, para permitir a evolução gradual do
entendimento
dos requisitos durante a implementação do software.

Item. 20. (CESPE / TCE-PR - 2016 - Item C) No modelo iterativo de desenvolvimento de
software, as
atividades são dispostas em estágios sequenciais.

Item. 21. (CESPE / STJ - 2015) Embora os engenheiros de software geralmente utilizem uma
abordagem
sistemática, a abordagem criativa e menos formal pode sereficiente em algumas
circunstâncias,
como, por exemplo, para o desenvolvimento de sistemas web, que requerem uma mistura de
habilidades de software e de projeto.

Item. 22. (CESPE / STJ - 2015) O foco da engenharia de software inclui
especificação do sistema,
desenvolvimento de hardware, elaboração do projeto de componentes de hardware e software,
definição dos processos e implantação do sistema.

Item. 23. (CESPE / STJ - 2015) As principais atividades de engenharia de software são
especificação,
desenvolvimento, validação e evolução.

Item. 24. (CESPE/TCE-RO-2013) Engenharia de software não está relacionada somente aos processos
técnicos de desenvolvimento de softwares, mas também a atividades como gerenciamento de
projeto e desenvolvimento de ferramentas, métodos e teorias que apoiem a
produção de
softwares.

Item. 25. (CESPE / TCE-RO - 2013) Assim como a Engenharia de Software, existe também na
área de
informática a chamada Ciência da Computação. Assinale a alternativa que melhor apresenta
a
diferença entre Engenharia de Software e Ciência da Computação.


a) A Ciência da Computação tem como objetivo o desenvolvimento de
teorias e
fundamentações. Já a Engenharia de Software se preocupa com as práticas de
desenvolvimento
de software.

b) A Engenharia de Software trata da criação dos sistemas de computação (softwares)
enquanto
a Ciência da Computação está ligada ao desenvolvimento e criação de
componentes de
hardware.

c) A Engenharia de Software trata dos sistemas com base em computadores,
que inclui
hardware e software, e a Ciência da Computação trata apenas dos aspectos de
desenvolvimento
de sistemas.

d) A Ciência da Computação trata dos sistemas com base em computadores,
que inclui
hardware e software, e a Engenharia de Software trata apenas dos
aspectos de
desenvolvimento de sistemas.

e) A Ciência da Computação destina-se ao estudo e solução para problemas genéricos das áreas
de rede e banco de dados e a Engenharia de Software restringe- se ao desenvolvimento
de
sistemas.

Item. 26. (CESPE /TRT10-2013) As atividades fundamentais relacionadas ao processo de construção
de
um software incluem a especificação, o desenvolvimento, a validação e a evolução do software.

Item. 27. (CESPE / TRT10 - 2013) O ciclo de vida de um software, entre outras
características, está
relacionado aos estágios de concepção, projeto, criação e implementação.

Item. 28. (CESPE /TRT-17- 2013) O objetivo do RAD é separar os modelos da visualização e
do controle.
Ele fornece o controlador e facilita a escrita de moldes padronizados para
a camada de
visualização.

2g.(CESPE / MEC - 2011) O processo de desenvolvimento de software é uma
caracterização
descritiva ou prescritiva de como um produto de software deve ser desenvolvido.

Item. 30. (CESPE / MEC - 2011) Atividades comuns a todos os processos de
software incluem a
especificação, o projeto, a implementação e a validação.

Item. 31. (CESPE / TJ-ES - 2011) Entre as etapas do ciclo de vida de software, as menos
importantes
incluem a garantia da qualidade, o projeto e o estudo de viabilidade. As demais
atividades do
ciclo, como a implementação e os testes, requerem maior dedicação da equipe e são essenciais.

Item. 32. (CESPE / TJ-ES - 2011) O modelo de processo incremental de desenvolvimento de
software é
iterativo, assim como o processo de prototipagem. Contudo, no processo
incremental,
diferentemente do que ocorre no de prototipagem, o objetivo consiste em
apresentar um
produto operacional a cada incremento.


33- (CESPE / AL-ES - 2011) O ciclo de vida RAD (Rapid Application Development), por
privilegiar a
rapidez do desenvolvimento, não possui etapa de modelagem.

Item. 34. (CESPE / DETRAN/ES - 2010) Segundo princípio da engenharia de software, os vários
artefatos
produzidos ao longo do seu ciclo de vida apresentam, de forma geral, nível de
abstração cada
vez menor.

Item. 35. (CESPE/TRE-BA-2oIo) Entre os desafios enfrentados pela engenharia de software estão
lidar
com sistemas legados, atender à crescente diversidade e atender às exigências quanto a
prazos
de entrega reduzidos.

Item. 36. (CESPE /TRE-BA-2010) Um modelo de processo de software consiste em uma representação
complexa de um processo de software, apresentada a partir de uma perspectiva genérica.

Item. 37. (CESPE / EMBASA - 2010) Ciclo de vida de um software resume-se em eventos
utilizados para
definir o status de um projeto.

Item. 38. (CESPE / DETRAN-ES - 2010) Quando um aplicativo de software desenvolvido
em uma
organização atinge, no fim do seu ciclo de vida, a fase denominada
aposentadoria,
descontinuação ou fim de vida, todos os dados por ele manipulados podem ser descartados.

Item. 39. (CESPE / BASA-2010) No modelo em cascata, o projeto segue uma série de passos
ordenados.
Ao final de cada projeto, a equipe de projeto finaliza uma revisão. O desenvolvimento
continua
e, ao final, o cliente avalia a solução proposta.

Item. 40. (CESPE / ANAC - 2009) O termo engenharia pretende indicar que o
desenvolvimento de
software submete-se a leis similares às que governam a manufatura de produtos
industriais em
engenharias tradicionais, pois ambos são metodológicos.

Item. 41. (CESPE / TCE-TO - 2009 - Item A) Quanto maior e mais complexo o projeto de
software, mais
simples deve ser o modelo de processo a ser adotado.

Item. 42. (CESPE / TCE-TO - 2009 - Item B) O modelo de ciclo de vida do software serve
para delimitar
o alvo do software. Nessa visão, não são consideradas as atividades
necessárias e o
relacionamento entre elas.

43.(CESPE / INMETRO - 2009) Em uma empresa que tenha adotado um
processo de
desenvolvimento de software em cascata, falhas no levantamento de requisitos
têm maior
possibilidade de gerar grandes prejuízos do que naquelas que
tenham adotado
desenvolvimento evolucionário.


44-(CESPE / INMETRO - 2009) Em um processo de desenvolvimento em cascata, os testes de
software são realizados todos em um mesmo estágio, que acontece após a finalização das
fases
de implementação.

Item. 45. (CESPE / IPEA - 2009) No modelo em cascata de processo de desenvolvimento, os
clientes
devem definir os requisitos apenas durante a fase de projeto; e os
projetistas definem as
estratégias de projeto apenas durante a fase de implementação. As fases do
ciclo de vida
envolvem definição de requisitos, projeto, implementação, teste, integração,
operação e
manutenção. Em cada fase do ciclo de vida, podem ser produzidos diversos artefatos.

Item. 46. (CESPE - 2009 - INMTRO - Analista de Sistema) No desenvolvimento de software, o
modelo
em cascata é estruturado de tal maneira que as fases que compõem o desenvolvimento são
interligadas. Nessa situação, o final de uma fase implica o início de outra.

Item. 47. (CESPE / TRE-MT - 2009 - Item A) O modelo em cascata é apropriado para
software em que
os requisitos ainda não foram bem compreendidos, pois é focado na criação de incrementos.

Item. 48. (CESPE / UNIPAMPA - 2009 - Item D) O modelo em cascata sugere uma
abordagem
sistemática e sequencial para o desenvolvimento de software. Sua natureza linear leva a
estados
de bloqueio nos quais, para que nova etapa seja iniciada, é necessário que a
documentação
associada à fase anterior tenha sido aprovada.

Item. 49. (CESPE / UNIPAMPA- 2009) No modelo de desenvolvimento incremental, a cada iteração
são
realizadas várias tarefas. Na fase de análise, pode ser feito o refinamento de
requisitos e o
refinamento do modelo conceituai.

Item. 50. (CESPE / INPE - 2008) O ciclo de vida do software tem início na fase de projeto.

Item. 51. (CESPE / TST- 2008) No modelo de desenvolvimento sequencial linear, a fase de
codificação
é a que gera erros de maior custo de correção.

Item. 52. (CESPE / SERPRO - 2008) O modelo em cascata consiste de fases e atividades que
devem ser
realizadas em sequência, de forma que uma atividade é requisito da outra.

Item. 53. (CESPE / MPE-AM - 2008) O modelo de desenvolvimento sequencial linear
tem como
característica principal a produção de uma versão básica, mas funcional, do software
desde as
primeiras fases.

Item. 54. (CESPE / TJ-DF - 2008) No modelo de desenvolvimento incremental, embora haja
defasagem
entre os períodos de desenvolvimento de cada incremento, os incrementos são desenvolvidos
em paralelo.

Item. 55. (CESPE/TST-2008) O modelo RAD (Rapid Application Development) consiste em uma forma
de prototipação para esclarecer dúvidas da especificação do software.


Item. 56. (CESPE / TRE-MA - 2008) O modelo RAD (Rapid Application Development) é uma
adaptação
de alta velocidade do modelo sequencial linear, conseguido por meio da construção
embasada
em componentes.

Item. 57. (CESPE/TRE-MA-2oo8) O uso de uma abordagem de construção embasada em componentes
faz que o desenvolvimento no modelo RAD (Rapid Application Development) seja considerado
mais rápido

Item. 58. (CESPE / MPE-AM - 2008) O modelo de desenvolvimento incremental combina
características
do modelo de desenvolvimento sequencial linear com características do modelo RAD, embora
isso resulte em projetos que sistematicamente apresentam maior duração que
aqueles feitos
com os dois modelos de desenvolvimento originais.

Item. 59. (CESPE / TSE - 2006 - Item D) O modelo em cascata organiza o desenvolvimento em
fases.
Esse modelo encoraja a definição dos requisitos antes do restante do
desenvolvimento do
sistema. Após a especificação e a análise dos requisitos, têm-se o projeto, a
implementação e o
teste.

Item. 60. (CESPE / MPE-AM - 2005) O modelo RAD (rapid application development) é específico
para
projetos de software que empregam linguagens de programação de terceira geração.

Item. 61. (CESPE / IGEPREV - 2005) O modelo Rapid Application Development (RAD) é
apropriado para
projetos que envolvem grandes riscos técnicos.

Item. 62. (CESPE / ANS - 2005) O modelo Rapid Application Development (RAD) é uma
adaptação do
modelo em espiral para atender a projetos de software fundamentados em componentes.

Item. 63. (CESPE / AL-ES - 2005 - Item B) O modelo de desenvolvimento em cascata descreve
ciclos
sequenciais, incrementais e iterativos, possuindo, entre outras, as fases de
requisitos e
implementação.

Item. 64. (CESPE / STJ - 2004) O modelo de desenvolvimento sequencial linear,
também chamado
modelo clássico ou modelo em cascata, caracteriza-se por não acomodar adequadamente as
incertezas que existem no início de um projeto de software, em especial as
geradas pela
dificuldade do cliente de explicitar todos os requerimentos que o programa deve contemplar.

Item. 65. (CESPE / TJ-PA - 2004 - Item D) A abordagem sistemática estritamente
linear para o
desenvolvimento de software é denominada modelo em cascata ou modelo sequencial linear.

Item. 66. (CESPE / ABIN - 2004) O modelo de desenvolvimento seqüencial
linear, também
denominado modelo em cascata, é incompatível com o emprego de técnica de análise
orientada
a objetos no desenvolvimento de um sistema de informação.


67-(CESPE / TRE-AL - 2004) O modelo cascata ou ciclo de vida clássico
necessita de uma
abordagem sistemática, que envolve, em primeiro lugar, o projeto e, em seguida, a
análise, a
codificação, os testes e a manutenção.

Item. 68. (CESPE / BASA - 2004) O modelo embasado em prototipagem é um modelo de processo
incremental que enfatiza um ciclo de desenvolvimento extremamente curto. A primeira fase
do
processo é a modelagem de negócio e a última é a fase de teste e entrega.


GABARITo

Item. 1. CORRETO 24. CORRETO
47- ERRADO

Item. 2. CORRETO 25- LETRA A
Item. 48. CORRETO

3- CORRETO 26. CORRETO
49- CORRETO

4- CORRETO 27- CORRETO
Item. 50. ERRADO

5- LETRA B 28. ERRADO
51- ERRADO

Item. 6. CORRETO 29. CORRETO
Item. 52. CORRETO

7- ERRADO 30. CORRETO
53- ERRADO

Item. 8. ERRADO 31- ERRADO
54- CORRETO

9- CORRETO 32. CORRETO 55-
ERRADO

Item. 10. CORRETO 33- ERRADO
Item. 56. CORRETO

li. LETRA E 34- CORRETO
57- CORRETO

Item. 12. ERRADO 35- CORRETO
Item. 58. ERRADO

13- ERRADO 36. ERRADO
59- CORRETO

14- ERRADO 37- ERRADO
Item. 60. LETRA E

x5- ERRADO 38. ERRADO
Item. 61. ERRADO

i6. LETRA E 39- ERRADO
Item. 62. ERRADO

17- CORRETO 40. CORRETO 63.
ERRADO

i8. ERRADO 41. ERRADO
Item. 64. CORRETO

Item. 19. ERRADO 42. ERRADO
Item. 65. CORRETO

Item. 20. ERRADO 43- CORRETO
Item. 66. ERRADO

Item. 21. CORRETO 44. ERRADO
Item. 67. ERRADO

Item. 22. ERRADO 45- ERRADO
Item. 68. ERRADO

23- CORRETO 46. CORRETO


LISTA DE QUESTõES - FCC

í. (FCC / TRF - 3a REGIÃO - 2019) Considere a figura abaixo.

Atividades simultâneas


Descrição
do esboço

Especificação

I i

► Desenvolvimento

II

Validação

O modelo de processo de software representado é:

a) orientado a reuso.

b) desenvolvimento incremental.

c) em cascata.

d) processo empírico.

e) processo unificado.

Item. 2. (FCC / TST - 2012) A Engenharia de Software:

a) é uma área da computação que visa abordar de modo sistemático as questões técnicas
e não
técnicas no projeto, implantação, operação e manutenção no desenvolvimento de um software.

b) consiste em uma disciplina da computação que aborda assuntos relacionados a técnicas
para
a otimização de algoritmos e elaboração de ambientes de desenvolvimento.

c) trata-se de um ramo da TI que discute os aspectos técnicos e empíricos nos
processos de
desenvolvimento de sistemas, tal como a definição de artefatos para a modelagem ágil.

d) envolve um conjunto de itens que abordam os aspectos de análise de mercado,
concepção e
projeto de software, sendo independente da engenharia de um sistema.

e) agrupa as melhores práticas para a concepção, projeto, operação e manutenção de
artefatos
que suportam a execução de programas de computador, tais como as
técnicas de
armazenamento e as estruturas em memória principal.

Item. 3. (FCC / TRT6 - 2012) Considere: é uma disciplina que se ocupa de todos os aspectos da produção
de software, desde os estágios iniciais de especificação do sistema até a manutenção desse sistema,


depois que ele entrou em operação. Seu principal objetivo é fornecer uma estrutura
metodológica
para a construção de software com alta qualidade. A definição refere-se:

a) ao ciclo de vida do software.

b) à programação orientada a objetos.

c) à análise de sistemas.

d) à engenharia de requisitos.

e) à engenharia de software.

Item. 4. (FCC / MPE-AP - 2012) Um processo de software é um conjunto de atividades
relacionadas que
levam à produção de um produto de software. Existem muitos processos de software
diferentes,
mas todos devem incluir quatro atividades fundamentais: especificação,
projeto e
implementação, validação e:

a) teste
b) evolução.

c) prototipação.

d) entrega.

e) modelagem.

Item. 5. (FCC /TJ-RJ- 2012- Item E) Dos diferentes modelos para o ciclo de vida de
desenvolvimento
de um software é correto afirmar que o modelo em cascata é o mais recente e complexo.

Item. 6. (FCC/INFRAERO-2011) E m relação à Engenharia de Software, é INCORRETO afirmar:

a) O design de software, ao descrever os diversos aspectos que estarão presentes no
sistema
quando construído, permite que se faça a avaliação prévia para garantir que ele
alcance os
objetivos propostos pelos interessados.

b) A representação de um design de software mais simples para representar apenas as
suas
características essenciais busca atender ao princípio da abstração.

c) Iniciar a entrevista para obtenção dos requisitos de software com perguntas mais
genéricas e
finalizar com perguntas mais específicas sobre o sistema é o que caracteriza
a técnica de
entrevista estruturada em funil.

d) No contexto de levantamento de requisitos, funcionalidade é um dos aspectos que
deve ser
levado em conta na abordagem dos requisitos funcionais.

e) A representação é a linguagem do design, cujo único propósito é descrever um
sistema de
software que seja possível construir.

Item. 7. (FCC / TRE-AM - 2010) A Engenharia de Software:


a) não tem como método a abordagem estruturada para o desenvolvimento de software, pois
baseia-se exclusivamente nos modelos de software, notações, regras e
técnicas de
desenvolvimento.

b) se confunde com a Ciência da Computação quando ambas tratam do desenvolvimento de
teorias, fundamentações e práticas de desenvolvimento de software.

c) tendo como foco apenas o tratamento dos aspectos de construção de software,
subsidia a
Engenharia de Sistemas no tratamento dos sistemas baseados em computadores,
incluindo
hardware e software.

d) tem como foco principal estabelecer uma abordagem sistemática de
desenvolvimento,
através de ferramentas e técnicas apropriadas, dependendo do problema a ser
abordado,
considerando restrições e recursos disponíveis.

e) segue princípios, tais como, o da Abstração, que identifica os aspectos importantes
sem
ignorar os detalhes e o da Composição, que agrupa as atividades em um único processo
para
distribuição aos especialistas.

Item. 8. (FCC / DPE/SP - 2010) A Engenharia de Software:

I. não visa o desenvolvimento de teorias e fundamentações, preocupando-se unicamente com
as práticas de desenvolvimento de software.

II. tem como foco o tratamento dos aspectos de desenvolvimento de software,
abstraindo-se
dos sistemas baseados em computadores, incluindo hardware e software.

III. tem como métodos as abordagens estruturadas para o desenvolvimento de software que
incluem os modelos de software, notações, regras e maneiras de desenvolvimento.

IV. segue princípios, tais como, o da Abstração, que identifica os aspectos
importantes sem
ignorar os detalhes e o da Composição, que agrupa as atividades em um único processo
para
distribuição aos especialistas.

É correto o que se afirma em:

a) III e IV, apenas.

b) 1,11, III e IV.

c) I e II, apenas.

d) I, II e III, apenas.

e) II, III e IV, apenas.

Item. 9. (FCC/ AFR/SP - 2009) A engenharia de software está inserida no contexto:


a) das engenharias de sistemas, de processo e de produto.

b) da engenharia de sistemas, apenas.

c) das engenharias de processo e de produto, apenas.

d) das engenharias de sistemas e de processo, apenas.

e) das engenharias de sistemas e de produto, apenas.

io. (FCC / SEFAZ-SP - 2009 - Item B) O processo de engenharia de software denominado ciclo de
vida clássico refere-se ao modelo incremental.


GABARITo

Item. 1. LETRA B

Item. 2. LETRA A

Item. 3. LETRA E

Item. 4. LETRA B

Item. 5. ERRADO

Item. 6. LETRA E

Item. 7. LETRA D

Item. 8. LETRA D

Item. 9. LETRA A

Item. 10. ERRADO


LISTA DE QUESTõES - FCV

í. (FGV / COMPESA- 2016) Observe a figura a seguir, que representa um modelo de processo
de software.

Este modelo, algumas vezes chamado ciclo de vida clássico, sugere uma abordagem
sequencial
e sistemática para o desenvolvimento de software nos casos em que os
requisitos de um
problema são bem compreendidos e quando o trabalho flui da comunicação ao emprego de
forma relativamente linear. O modelo apresentado é denominado:

a) incremental.

b) cascata.

c) evolucionário.

d) unificado
e) especializado.

Item. 2. (FGV / PGE-RO - 2015) A figura abaixo ilustra um modelo de processo, que
prescreve um
conjunto de elementos de processo como atividades de arcabouço, ações de engenharia de
software, tarefas, produtos de trabalho, mecanismos de garantia de qualidade e de
controle de
modificações para cada projeto.

Esse modelo é conhecido como Modelo:

a) porfunções.

b) em cascata.


c) incremental.

d) em pacotes.

e) por módulos.

Item. 3. (FGV / BADESC - 2010) De acordo com Pressman, a engenharia de software é
baseada em
camadas, com foco na qualidade. Essas camadas são:

a) métodos, processo e teste.

b) ferramentas, métodos e processo.

c) métodos, construção, teste e implantação.

d) planejamento, modelagem, construção, validação e implantação.

e) comunicação, planejamento, modelagem, construção e implantação.

Item. 4. (FGV / Fiocruz - 2010) Rapid Application Development (RAD) é um modelo de
processo de
software incremental que enfatiza um ciclo de desenvolvimento curto, com o
uso de uma
abordagem de construção baseada em componentes. Nesse modelo, três das principais fases
são abrangidas pelas modelagens:

a) do negócio, dos recursos financeiros e das funções gerenciais.

b) do gerenciamento, dos recursos de TI e dos processos.

c) do planejamento, dos dados e das funções gerenciais.

d) do planejamento, dos recursos de TI e dos projetos
e) do negócio, dos dados e dos processos.

Item. 5. (FGV/CODESP-SP-2010) AUMLé uma linguagem visual para modelar sistemas
orientados a
objetos, sendo independente tanto de linguagens de programação quanto de
processos de
desenvolvimento. Nesse contexto, analise a figura abaixo, que representa um modelo de
ciclo
de vida para desenvolvimento de sistemas. Essa abordagem divide o
desenvolvimento de
software em ciclos, em que, em cada ciclo, podem ser identificadas as fases de
análise, projeto,
implementação e testes. Cada um dos ciclos considera um subconjunto de requisitos, e
estes
são desenvolvidos uma vez que sejam alocados a um ciclo de desenvolvimento. Esse
modelo de
ciclo de vida é denominado:

a) clássico;

b) em cascata;

c) prototipação;

d) estruturado por fases;

e) incremental e iterativo.

Item. 6. (FGV / Senado Federal - 2008) Considere as seguintes assertivas sobre modelos de
processos
de software:

I. No modelo em cascata, a fase seguinte não deve iniciar antes que a fase precedente tenha sido
concluída.


II. No modelo evolucionário, a mudança constante tende a corromper a estrutura do software

III. A explícita consideração dos riscos no modelo em espiral distingue esse modelo
dos modelos
em cascata e evolucionário.

As assertivas corretas são:

a) somente I.

b) somente I e II.

c) somente I e III.

d) somente II e III.

e) I, lie III.


GABARITo

Item. 1. LETRAB

Item. 2. LETRAB

Item. 3. LETRAB

Item. 4. LETRAE

Item. 5. LETRAE

Item. 6. LETRAE


LISTA DE QUESTõES - DIVERSAS

í. (VUNESP/TJM-SP -2021) O modelo de desenvolvimento de software RAD (Rapid
Application
Development) conta com uma fase de Modelagem, que compreende a modelagem de:

a) Negócio, Dados e Processo.

b) Teste, Integração e Negócio.

c) Protótipo, Entrega e Dados.

d) Comunicação, Integração e Teste.

e) Entrega, Comunicação e Protótipo.

Item. 2. (VUNESP/ PRODEST-ES-2014) No modelo de ciclo de vida de software conhecido como
RAD
(Rapid Application Development) há duas atividades, cujas tarefas podem ser distribuídas
por
diversas equipes. Essas atividades são:

a) comunicação e modelagem
b) comunicação e planejamento.

c) integração e construção.

d) modelagem e construção.

e) planejamento e integração.

Item. 3. (VUNESP / SPTrans - 2012) Uma das abordagens do processo de
desenvolvimento da
engenharia de software prevê a divisão em etapas, em que o fim de uma é a entrada
para a
próxima. Esse processo é conhecido como modelo:

a) Transformação.

b) Incremental.

c) Evolutivo.

d) Espiral.

e) Cascata.

Item. 4. (CESGRANRIO / UNIRIO - 2019) O modelo de processo incremental é iterativo por
natureza e
produz a cada incremento uma versão operacional do produto, diferente de outros modelos,
como, por exemplo, a prototipagem. Esse modelo incremental:

a) gera incrementos logo nas primeiras etapas, mas estes não podem ser entregues ao cliente.

b) possui unicamente atividades de codificação e teste nos seus incrementos.

c) deve ter, no máximo, 1 a 5 sprints quando planejados e gerenciados com métodos ágeis.

d) possui atividades de teste fora do incremento, realizadas por outra equipe que vai
integrando
incrementalmente o produto a cada etapa do teste.

e) combina elementos do modelo cascata, aplicado de maneira iterativa, sendo também
essa
filosofia incremental usada em processos ágeis.


5- (CESGRANRIO / Transpetro - 2018) O modelo em cascata ou linear é um modelo de
processo
de software que, a princípio, só deve ser usado se o(s):

a) feedback do usuário é necessário ao longo do desenvolvimento.

b) requisitos devem mudar ao longo do projeto.

c) requisitos são bem conhecidos.

d) riscos de negócio não são conhecidos.

e) usuários não sabem bem o que desejam.

Item. 6. (CESGRANRIO/Transpetro-2018) Que tipo de processo de desenvolvimento de software visa
a, inicialmente, prover todas as funcionalidades do sistema com uma fidelidade baixa e,
por
meio de ciclos, ir aumentando cada vez mais a fidelidade até que todas as
funcionalidades
estejam suportadas com a fidelidade máxima?

a) Preditivo
b) Linear
c) Iterativo
d) Incremental
e) Ágil

Item. 7. (CESGRANRIO / Transpetro - 2012) Na engenharia de software, existem diversos
modelos de
desenvolvimento de software, e, dentre eles, o modelo em cascata, o qual, no contexto
do
desenvolvimento de sistemas de software complexos, recomenda:

a) distribuir a elicitação dos requisitos desde o início até 0 fim do desenvolvimento.

b) dividir o desenvolvimento do produto de software em fases lineares e sequenciais.

c) enfatizar a avaliação e mitigação de riscos durante o desenvolvimento.

d) realizar entregas incrementais do produto de software ao longo do desenvolvimento.

e) usar prototipagem rápida para estimular o envolvimento do usuário no desenvolvimento.

Item. 8. (CESGRANRIO / EPE - 2012) Uma das críticas feitas ao modelo do ciclo
de vida do
desenvolvimento de software em cascata refere-se a:

a) exigência de conhecimento de avaliação e gerenciamento de risco para
evitar grandes
surpresas no projeto.

b) comprometimentos na qualidade e nas possibilidades de manutenção a longo
prazo,
parecendo um protótipo.

c) pouca flexibilidade para mudanças futuras, exigindo compromissos nas fases
iniciais do
projeto.


d) pouca visibilidade das etapas do processo, tornando cara a documentação de todas as
versões
dos sistemas.

e) exigências de velocidade as quais levam o engenheiro de software a utilizar
linguagens,
algoritmos ou ferramentas ineficientes ao longo de todo o projeto.

Item. 9. (CESGRANRIO / PETROBRÁS - 2011) A especificação de uma
Metodologia de
Desenvolvimento de Sistemas tem como pré-requisito indispensável, em relação ao que será
adotado no processo de desenvolvimento, a definição do:

a) Engenheiro Responsável pelo Projeto
b) Documento de Controle de Sistemas
c) Software para Desenvolvimento
d) Ciclo de Vida do Software
e) Bloco de Atividades

Item. 10. (CESGRANRIO / PETROBRÁS - 2010) No Ciclo de Vida Clássico, também chamado de
Modelo
Sequencial Linear ou Modelo Cascata, é apresentada uma abordagem sistemática
composta
pelas seguintes atividades:

a) Análise de Requisitos de Software, Projeto, Geração de Código, Teste e Manutenção.

b) Modelagem e Engenharia do Sistema/lnformação, Análise de Requisitos de
Software,
Projeto, Geração de Código, Teste e Manutenção.

c) Modelagem e Engenharia do Sistema/lnformação, Projeto, Geração de Código,
Teste e
Manutenção.

d) Levantamento de Requisitos de Software, Projeto, Geração de Código e
Manutenção e
Análise de Requisitos de Software.

e) Levantamento de Requisitos de Software, Projeto, Geração de Código, Teste
Progressivo e
Manutenção.

n.(IBFC/ EBSERH - 2020) O ciclo de vida do software é a estrutura que
contém processos,
atividades e tarefas envolvidas no desenvolvimento, operação e manutenção de um produto
de
software. Assinale a alternativa que identifica corretamente o modelo mais antigo de
ciclo de
vida de software:

a) Espiral
b) Evolutivo
c) Incremental
d) Prototipagem
e) Cascata


Q-Q


Item. 12. (INSTITUTO AOCP / Prefeitura de Novo Hamburgo - RS - 2020) Existem diversos
modelos de
desenvolvimento de software na literatura. Sabendo disso é correto afirmar que o modelo
que
se baseia na ideia de desenvolver uma versão inicial do produto, apresentá-la
para os
comentários dos clientes e continuar o desenvolvimento, por meio da criação
de diversas
versões, até que um produto final adequado seja alcançado, é o:

a) modelo orientado a objetos.

b) modelo orientado ao reúso.

c) modelo incremental.

d) modelo cascata.

e) modelo híbrido.

Item. 13. (INSTITUTO AOCP / UFPB- 2019) Existem diferentes processos de software,
porém todos
devem ser compostos por quatro etapas fundamentais. Assinale a alternativa que
apresenta
essas etapas.

a) 1. Análise de Software; 2. Desenvolvimento de Software; 3. Validação de
Software; 4.
Evolução de Software.

b) 1. Especificação de Software; 2. Projeto e Implementação de Software; 3.
Validação de
Software; 4. Evolução de Software.

c) 1. Análise de Requisitos; 2. Projeto e Implementação de Software; 3. Teste de
Software; 4.
Evolução de Software.

d) 1. Análise de Requisitos; 2. Projeto e Implementação de Software; 3. Validação de
Software;

Item. 4. Suporte Técnico.

e) 1. Especificação de Software; 2. Desenvolvimento de Software; 3. Teste de Software;
4.
Implantação de Software.

14.OESES / SCGás - 2019) Assinale a associação correta presente na tabela

ASSOCIAÇÕES que define corretamente os elementos a definir da TABELA A com
as
definições ou caracterizações da TABELA B.


TABELA A

A definir

1 Os processos de
software são

2 Modelos de
processos de
software

3 Modelos gerais de
processo

4 Engenharia de
requisitos

5 Validação de
software

TABELA B

Definição ou caracterização

A Modelos de processos de software

B as atividades envolvidas na produção de um
sistema, de software
ê o processo de desenvolvimento de uma
C especificação de software

D descrevem a organização dos processos de
software

E ê o processo de verificação de que o sistema
está de acordo com sua especificação e
satisfaz às necessidades reais dos usuários
do sistema.


i5.(lnaz do Pará / CORE-SP - 2019) "O Modelo em Cascata (do inglês: Waterfall Model)
é um
modelo de desenvolvimento de software sequencial no qual o processo é visto como um
fluir
constante para frente (como uma cascata)"

Disponível em: https://pt.wikipedia.org/wiki/Modelo_em_cascata. Acesso em: 13.12.2018

No que tange ao processo de desenvolvimento de software em cascata, qual a
afirmativa
correta?

a) O modelo em cascata ou clássico também pode ser conhecido como "Bottom-UP".

b) Este modelo está defasado e não é mais utilizado, tendo sido descontinuado desde a
década
de 90.

c) As fases do modelo em cascata seguem a seguinte ordem: (1) Requerimento, (2)
Verificação,

(3) Projeto, (4) Implementação e (5) Manutenção.

d) As fases do modelo são como uma cascata, mantendo o fluxo do trabalho de cima
para baixo,
não podendo voltar às fases iniciais, somente pular etapas para frente.

e) A saída produzida em cada fase será utilizada como entrada da fase seguinte,
tornando o
modelo em cascata um modelo simples de entender e controlar.

i6.(IESES / SCGás - 2019) Assinale a alternativa que completa as lacunas
corretamente.
Considerando que o encadeamento entre uma fase e outra é uma das características do
modelo
em cascata, ou ciclo de vida de software. Este modelo é
um exemplo de.

Neste tipo de processo vocêe programar todas as atividades do processo antes de
a) um estágio - escrever - encerrar o projeto.

b) um processo dirigido a planos - deve planejar - começar a trabalhar nelas.


c) um estágio-deve planejar-encerrar o projeto.

d) um processo dirigido a planos-escrever-encerrar o projeto

Item. 17. (INSTITUTO AOCP / UFPB-2019) Há casos em que os requisitos de um problema são bem
compreendidos, por exemplo, quando o trabalho flui da comunicação ao emprego
de forma
relativamente linear. Sobre o modelo cascata, empregado na engenharia de software,
assinale
a alternativa correta.

a) O modelo cascata, algumas vezes denominado ciclo de vida clássico, sugere uma
abordagem
sequencial e sistemática para o desenvolvimento do software, começando com o levantamento
de necessidades por parte do cliente, avançando pelas fases de planejamento,
modelagem,
construção, emprego e culminando no suporte contínuo do software concluído.

b) O modelo cascata é projetado para o desenvolvimento do software de forma incremental.

c) O modelo cascata nada mais é que a criação de protótipos.

d) No modelo cascata, o software é desenvolvido em uma série de versões
evolucionárias. Nas
primeiras iterações, a versão pode consistir em um modelo ou em um protótipo.

e) O modelo cascata combina fluxos de processo linear e paralelo dos elementos. Esse
modelo
aplica as sequências lineares de forma escalonada. Cada sequência linear produz
incrementos
entregáveis do software.

Item. 18. (AOCP / EMPREL - 2019) O ciclo de vida clássico, que foi o primeiro modelo
publicado de
desenvolvimento de software, é conhecido como:

a) Cascata.

b) Espiral.

c) Incremental.

d) Evolucionário.

e) Prototipação.

ig.(IBFC / Emdec - 2019) Sobre alguns modelos do ciclo de vida de desenvolvimento de
software,
assinale a alternativa correta.

a) Incremental
b) Curva
c) Estrela
d) Circular

2o.(SELECON / Prefeitura de Boa Vista - RR-2019) No que tange à Engenharia de
Software, um
dos ciclos de vida para o desenvolvimento de sistemas preconiza que os requisitos do
cliente são
obtidos e, de acordo com a funcionalidade, são agrupados em módulos. Após este
agrupamento, a equipe, junto ao cliente, define a prioridade em que cada
módulo será
desenvolvido, escolha baseada na importância daquela funcionalidade ao negócio do
cliente.
Cada módulo passa por todas as fases de projeto, conforme se observa na figura a
seguir, e será
entregue ao cliente um software operacional. Assim, o cliente receberá parte do produto
final
em menos tempo.

Esse ciclo de vida é conhecido como:

a) cascata
b) espiral
c) incremental
d) evolutivo

2i.(FAURGS/ BANRISUL - 2018) se preocupa com todos os
aspectos do
desenvolvimento de sistemas computacionais, incluindo engenharia de hardware,
software e
processo; eé uma disciplina da engenharia que se preocupa com todos
aspectos da
produção de software, desde os estágios iniciais da especificação do sistema
até sua
manutenção, quando o sistema já está sendo usado.

Assinale a alternativa que completa, correta e respectivamente, as lacunas do texto acima.

a) Engenharia de Domínio - Engenharia de Software
b) Engenharia Reversa - Engenharia de Sistemas
c) Engenharia de Sistemas - Engenharia de Domínio
d) Engenharia de Sistemas - Engenharia de Software
e) Engenharia Reversa - Engenharia de Domínio

22.(FAURGS/ BANRISUL - 2018) Considere as seguintes afirmações sobre
Princípios de
Engenharia de Software.

I - São utilizadas diferentes técnicas de engenharia de software para cada tipo de
sistema,
porque cada software tem características bastante diversas.


II - Uma característica fundamental de um sistema de software é a
eficiência, pois
o software não deve desperdiçar os recursos do sistema, como memória e ciclos do
processador.
Eficiência inclui capacidade de resposta, tempo de processamento, uso da memória, etc.

III - Engenheiros de software não devem preocupar-se apenas com questões técnicas,
devendo
se comportar de forma ética e moralmente responsável, pois têm
responsabilidades com a
profissão de engenharia e com a sociedade.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

23.(FAURGS / TJ-RS - 2018) Considere as seguintes afirmações sobre o modelo
cascata de
desenvolvimento de software.

I - É um exemplo de processo dirigido a planos; em princípio, deve-se
planejar todas as
atividades do processo antes de se começar a trabalhar nelas.

II - É consistente com outros modelos de processos de engenharia e a
documentação é
produzida em cada fase do ciclo. Dessa forma, o processo torna-se visível e os
gerentes podem
monitorar o progresso de acordo com o plano de desenvolvimento.

III- Sua maior vantagem é a divisão inflexível do projeto em estágios distintos, de
forma que os
compromissos devem ser assumidos em um estágio inicial do processo, o que
facilita que
atendam às mudanças de requisitos dos clientes.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

24-(FAURGS/ BANRISUL-2018) Há vários modelos de processo de software, sendo que cada um
define um fluxo de processo que invoca cada atividade do desenvolvimento de forma
diversa. O
modelo , algumas vezes chamado ciclo de vida clássico, é um
exemplo de
processo dirigido a planos, pois deve-se planejar todas as atividades (estágios) do
processo
antes de começar a trabalhar nelas. Em princípio, o estágio seguinte não deve ser iniciado até
que o estágio anterior seja concluído, mas na prática este processo não é um modelo
linear
simples, envolvendo o feedback de um estágio a outro. Assim os documentos e
artefatos
produzidos em cada estágio podem ser modificados para refletirem as alterações em cada
um
deles. Este modelo é consistente com outros modelos de processo de
engenharia, e a
documentação é produzida em cada estágio do ciclo. Desta forma, o processo torna-se
visível e
os gerentes podem monitorar o progresso de acordo com o plano de desenvolvimento. Seu
maior problema é a divisão inflexível do projeto em estágios distintos e, por isso,
deve ser usado
apenas quando os requisitos são bem compreendidos e pouco provavelmente venham a ser
radicalmente alterados durante o desenvolvimento.

Assinale a alternativa que preenche corretamente a lacuna do texto acima:

a) cascata (waterfall)

b) espiral
c) orientado a desenvolvimento incremental
d) baseado em componentes
e) prototipação

Item. 25. (COSEPE / UFPI -2018) O modelo cascata é um dos paradigmas mais antigos da
engenharia de
software. Dentre os problemas às vezes encontrados quando se aplica o modelo cascata,
tem-
se:

a) A etapa de comunicação ser responsável pelo levantamento das necessidades.

b) A existência de uma variação na representação do modelo, denominada de modelo V.

c) O modelo ser equivocadamente aplicado a problemas com requisitos bem
definidos e
razoavelmente estáveis.

d) O uso do fluxo sequencial proposto pelo modelo, visto que projetos reais raramente
seguem
tal fluxo.

e) A existência de somente cinco etapas no modelo, da comunicação ao emprego.

Item. 26. (Gestão Concursos / EMATER - 2018) O processo de um software é um conjunto de
atividades
que conduz ao desenvolvimento do produto software e o modelo de processo é uma
descrição
simplificada do processo. Qual é a característica que define o modelo cascata?

a) Atividades intercaladas.

b) Atividades sequenciais.

c) Rápida entrega do software.

d) Existência de componentes reusáveis.

Item. 27. (FADESP / IF-PA - 2018) O modelo de desenvolvimento de software em cascata, também
conhecido como ciclo de vida clássico, sugere uma abordagem sistemática e sequencial
para o
desenvolvimento de softwares que começa com a especificação dos requisitos e
termina na
manutenção do software acabado. Nos últimos anos, este modelo de ciclo de desenvolvimento
vem sofrendo várias críticas quanto a sua eficácia. Assim, é correto afirmar que um
dos possíveis
problemas do ciclo de vida clássico é:

a) a exigência do modelo para que o cliente estabeleça todos os requisitos explicitamente.

b) a construção problemática dos componentes, caso o sistema não possa ser adequadamente
modularizado.

c) a responsabilidade do levantamento das necessidades pela etapa de comunicação.

d) a aplicação do modelo de forma incorreta a problemas com requisitos bem
definidos e
razoavelmente estáveis.

e) a existência de somente cinco etapas no modelo, da comunicação à imantação.

28.(QUADRIX / CRM-PR - 2018) É no estágio final do modelo em cascata, ou ciclo de
vida de
software, operação e manutenção, que o software é colocado em uso.

2g.(QUADRIX / CRM-PR - 2018) O modelo em cascata é composto por três estágios, que
são
independentes entre si: análise e definição de requisitos; implementação e
teste unitário; e
operação e manutenção.

Item. 30. (FAURGS / UFRGS - 2018) Considere as afirmações abaixo sobre Engenharia de Software:

I- A Engenharia de Software não se preocupa apenas com os processos técnicos do
desenvolvimento de software. Ela também inclui atividades como gerenciamento de projeto de
software e desenvolvimento de ferramentas, métodos e teorias para apoiar a produção de
software.

II - Por ser uma abordagem sistemática para a produção de software, a Engenharia de
Software
propõe técnicas e métodos universais que são adequados a todos os sistemas e a todas
as
empresas.

III - Um processo de software é uma sequência de atividades que leva à produção de
um produto
de software.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

Item. 31. (FAURGS / BANRISUL-2018) Considere as seguintes afirmações sobre processos de software.

I - Um processo de software é um conjunto de atividades relacionadas que levam à produção
de
um produto de software.


II - Os processos ágeis são uma categoria de processo de software em que o
planejamento não
é gradativo e, por isso, torna-se mais difícil alterar o processo de
maneira que reflita as
necessidades de mudança dos clientes.

III - Em organizações nas quais a diversidade de processos de software é reduzida, os
processos
de software podem ser melhorados pela padronização. Isso possibilita uma
melhor
comunicação, além de redução no período de treinamento, e torna mais econômico o apoio
ao
processo automatizado.

Quais estão corretas?

a) Apenas I.

b) Apenas I e II.

c) Apenas I e III.

d) Apenas II e III.

e) I, lie III.

Item. 32. (IBADE/ IPM - JP - 2018) No que diz respeito à Engenharia de Software, um
modelo de
processo é visualizado como um ciclo de vida constituído da especificação, do
desenvolvimento,
da validação e da evolução, e as representa como fases do processo, cada uma separada
das
outras, tais como especificação de requisitos, projeto de software, implementação e
testes. Esse
modelo de processo é denominado Modelo:

a) baseado em Prototipação.

b) baseado em Eventos.

c) em Espiral.

d) em Árvore.

e) em Cascata.

Item. 33. (AOCP / UNIR - 2018) No modelo cascata, o resultado de cada fase envolve um ou
mais
documentos que são aprovados e assinados. A fase seguinte só é iniciada após a
conclusão da
fase precedente, mas, na prática, eles se sobrepõem e trocam informações. Durante o
projeto,
são identificados problemas com os requisitos; durante a codificação, são verificados
problemas
do projeto, e assim por diante. O processo não é um modelo linear simples, mas
envolve uma
sequência de iterações das atividades de desenvolvimento.

Item. 34. (FUNDATEC / CIGA-SC - 2018) Para responderá questão, considere a Figura 8, que
mostra,
esquematicamente, um modelo de processo ou paradigma da engenharia de software, utilizado
no desenvolvimento de sistemas computacionais.


A Figura 8 exibe, esquematicamente, o modelo de processo de desenvolvimento de software,
chamado de:

a) Espiral.

b) Cascata.

c) Prototipação.

d) Orientado a reuso.

e) Desenvolvimento incremental.

35.(COMPERVE I UFRN - 2018) Considere as afirmativas apresentadas abaixo a respeito dos
modelos de processos de software cascata (waterfall) e incremental.

I Uma das vantagens do modelo de processo cascata é que ele antecipa eventuais
correções a
serem feitas nos requisitos do software.

II O modelo de processos cascata é recomendado quando os requisitos são estáveis e claros.

III No desenvolvimento incremental, a arquitetura e o projeto do software tendem a
manter-se
estáveis.

IV No desenvolvimento incremental, o acompanhamento e o progresso das
atividades são
avaliados pela entrega de artefatos.

Estão corretas as afirmativas:

a) lie IV.

b) I e IV.

c) I e III.

d) lie III.


Item. 36. (I ES ES / CEGÁS - 2017) Assinale a alternativa que preenche as lacunas corretamente
relativa a
definição abaixo para Engenharia de Software.

De acordo com a IEEE Engenharia de Software é a aplicação de uma abordagem
sistemática,
e quantificável no desenvolvimento,e manutenção de softwares.

a) Incremental - documentação.

b) Estruturada - implantação.

c) Disciplinada - operação.

d) Completa - implementação.

Item. 37. (COPESE / UFPI - 2014) O modelo RAD (Rapid Application Development) é
um modelo
incremental que enfatiza um ciclo de desenvolvimento curto, sendo construído
baseado em
componentes.

Item. 38. (MPE-RS / MPE-RS -2012) O ciclo de vida básico de um software compreende:

a) a implementação, a implantação e o teste.

b) a análise, a segurança e o controle de usuários.

c) a implementação, a análise e o teste.

d) a implementação, a validação e as vendas.

e) a análise, o projeto, a implementação e o teste.

Item. 39. (Instituto Cidade / TCM-GO - 2012) De acordo com a engenharia de software, como
todo
produto industrial, o software possui um ciclo de vida. Cada fase do ciclo de vida
possui divisões
e subdivisões. Em qual fase avaliamos a necessidade de evolução dos softwares
em
funcionamento para novas plataformas operacionais ou para a incorporação
de novos
requisitos?

a) Fase de operação;

b) Fase de retirada;

c) Fase de definição;

d) Fase de design.

e) Fase de desenvolvimento;

Item. 40. (UPANET/ JUCEPE-2012) O Desenvolvimento Rápido de Aplicações (RAD - Rapid Application
Development) pode fazer uso do processo de desenvolvimento conjunto de aplicações (JAD -
Joint Application Development) para coletar dados e analisar requisitos.

Item. 41. (FUNIVERSA / IPHAN - 2009) A Engenharia de Software resume-se em um
conjunto de
técnicas utilizadas para o desenvolvimento e manutenção de sistemas
computadorizados,
visando produzir e manter softwares de forma padronizada e com qualidade. Ela obedece a
alguns princípios como (1) Formalidade, (2) Abstração, (3) Decomposição, (4) Generalização e


(5) Flexibilização. Assinale a alternativa que apresenta conceito correto sobre os
princípios da
Engenharia de Software.

a) A flexibilização é o processo que permite que o software possa ser alterado, sem
causar
problemas para sua execução.

b) A formalidade é a maneira usada para resolver um problema, deforma genérica, com o
intuito
de poder reaproveitar essa solução em outras situações semelhantes.

c) A generalização preocupa-se com a identificação de um determinado fenômeno da
realidade,
sem se preocupar com detalhes, considerando apenas os aspectos mais relevantes.

d) Pelo princípio da decomposição, o software deve ser desenvolvido de acordo com
passos
definidos com precisão e seguidos de maneira efetiva.

e) A abstração é a técnica de se dividir o problema em partes, de maneira que cada
uma possa
ser resolvida de uma forma mais específica.


GABARITo

Item. 1. LETRA A 15- LETRA E
Item. 29. ERRADO

Item. 2. LETRA D i6. LETRA B
Item. 30. LETRAC

3- LETRA E 17- LETRA A
3i- LETRA C

4- LETRA E i8. LETRA A
Item. 32. LETRA E

5- LETRAC 19- LETRA A
33- CORRETO

Item. 6. LETRA C 20. LETRA C
34- LETRA B

7- LETRA B 21. LETRA D
35- LETRA A

Item. 8. LETRA C 22. LETRA E
Item. 36. LETRAC

9- LETRA D 23- LETRA B
37- CORRETO

Item. 10. LETRA B 24. LETRA A
Item. 38. LETRA E

íi. LETRA E 25- LETRA D
39- LETRA B

Item. 12. LETRA C 26. LETRA B
Item. 40. CORRETO

13- LETRA B 27- LETRA A
Item. 41. LETRA A

14- LETRA B 28. CORRETO


